---
title: 分布式系统的ID
date: 2019-03-29 11:40:02
tags: 分布式
id: 1553830839
---
在分布式系统中，为了适应可能有多台主（写）服务器，任何时刻都可能有服务器加进来或者去掉这种情况，就不能用传统的数据库自增ID方案。这篇文章介绍几个在分布式系统中用的ID生成方案。

# 业务服务器
业务服务器指的是我们写的后端服务器。这里的着重点是自己生成id，不需要数据库自己给出一个自增id。

## 自增
自增ID是最简单的方案，数据库自己提供了这个功能。但是一旦有多台写服务器就不能适用了。而且自增ID会影响写性能，在数据库的写性能是整个系统性能瓶颈的情况下，能减轻一点压力都是好的。

## 有序uuid
uuid是一个32位的字符串ID，在服务器本地生成，可以保证单机生成的ID在整个系统中独立。原始版本的uuid是无序的，这在数据库取出一系列有序数据时非常影响性能。幸好现在已经有了可以生成有序uuid的算法，比如 Laravel 的 Str::orderedUuid()。但是由于uuid是32位字符串，依然影响性能。

## snowflake
之前的文章[大型服务器的架构](/posts/1532314825)中描述了蚂蚁金服的id生成方案，即是一种类snowflake结构。原始的snowflake结构是

> 41位时间+10位机器编号+12位自增序列号

因为id中包含了机器号，所以能保证绝对不会和其他服务器生成的id重复。但是这要求机器自己知道自己的id，比如在初始化的时候从管理服务处获得，或者有一个独立的id生成服务器。

参考资料[1]介绍了一种 php 的 snowflake id 生成算法。

# 资源服务器
资源服务器指的是数据库或者缓存。这里的着重点是如何分布式存储数据，即每台服务器内容不同。

## 取模
获得业务服务器生成的id后，为了存储在不同的服务器，可以将id取模。比如我们有4台服务器，那么 id%4 的到的余数就是我们要的机器id，然后就可以存储到对应的数据库了。但是如果服务器数量增加或者减少，取模后的到的余数就不能对应到原来的机器id，原来的数据也就不能正常取出了。

## 一致性哈希算法
简单的来说，一致性哈希算法就是把数据 id 和 服务器 id 进行相同的哈希，然后存储在一个被分成 2^32 部分的圆中，存取的时候找到离数据右边最近的服务器。比如服务器id "S1", "S2" 哈希后投射到圆上的两个点，把这两个点中间的所有点取出来，就是下面这段

S1-------------------S2

这时有个数据id，哈希后的值落在 S1 S2 之间，会被存储在 S2 里。这时增加服务器 S3

S1---------S3----------S2

这时数据id哈希后落在 S1~S3 会存储在S3中，S3~S2 会存储在S2中。这里需要手动把S2里面应该落在S3的数据（永久缓存）手动转移到S3中。

参考资料[3][4]介绍了一种 php 的一致性哈希算法。

------------------------------
参考资料：  
[1]https://huoding.com/2016/11/03/552  
[2]https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368  
[3]https://blog.csdn.net/jt521xlg/article/details/49360895  
[4]http://www.cnblogs.com/phpfans/p/4641490.html