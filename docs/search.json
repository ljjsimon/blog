[{"title":"kubernetes基本操作","url":"/posts/1543981565/","content":"kubernetes 官方提供了非常好的交互学习平台 https://kubernetes.io/docs/tutorials/ ，这篇文章是当作一个命令参考，毕竟这些命令不常用，容易忘。\n\n# 基本概念\n- Cluster 集群，一个集群里有一个 Master 和数个 Node\n- Node 通常拿一台物理机座位图一个 Node，也可以用虚拟机\n- Pod 是一个 docker 实例，一个 Node 里有一个或多个 Pod\n- Deployment 一个发布，可以包含一个或多个 Pod\n- Service deployment 暴露出来的服务，内置了负载分发\n\n# 创建集群\n```sh\nkubernetes start # \b创建集群\n\n$ kubectl get nodes # 查看所有 nodes\nNAME       STATUS    ROLES     AGE       VERSION\nminikube   Ready     <none>    19s       v1.10.0\n```\n\n# 发布应用\n```sh\n$ kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080 # 启动一个应用\ndeployment.apps/kubernetes-bootcamp created\n\n$ kubectl get deployments # 查看所有应用\nNAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nkubernetes-bootcamp   1         1         1            1           50s\n\n$ kubectl proxy # 转发本地端口到 pod 的端口\n```\n\n# 查看应用\n```sh\n$ kubectl get pods # 查看所有 pods\nNAME                                   READY     STATUS    RESTARTS   AGE\nkubernetes-bootcamp-5c69669756-85r9w   0/1       Pending   0          1s\n\n$ kubectl describe pods # \b\b查看 pods 详情\nName:           kubernetes-bootcamp-5c69669756-85r9w\nNamespace:      default\nNode:           minikube/172.17.0.11\nStart Time:     Wed, 05 Dec 2018 05:55:14 +0000\nLabels:         pod-template-hash=1725225312\n                run=kubernetes-bootcamp\nAnnotations:    <none>\nStatus:         Running\nIP:             172.18.0.4\nControlled By:  ReplicaSet/kubernetes-bootcamp-5c69669756\nContainers:\n  kubernetes-bootcamp:\n    Container ID:   docker://a7a117005de01756ff3eb0800b91ef089810db413961c86d14fdf9cd8c451754\n    Image:          gcr.io/google-samples/kubernetes-bootcamp:v1\n    Image ID:       docker-pullable://gcr.io/google-samples/kubernetes-bootcamp@sha256:0d6b8ee63bb57c5f5b6156f446b3bc3b3c143d233037f3a2f00e279c8fcc64af\n    Port:           8080/TCP\n    Host Port:      0/TCP\n    State:          Running\n  .\n  .\n  .\n\n$ kubectl logs kubernetes-bootcamp-5c69669756-85r9w # pod 的访问日志\n$ kubectl exec kubernetes-bootcamp-5c69669756-85r9w env # \b在 pod 里执行 shell（查看环境变量）\n\b$ kubectl exec -ti kubernetes-bootcamp-5c69669756-85r9w bash # 登录到 pod 里\n```\n\n# 暴露应用\n## \b创建服务\n```sh\n$ kubectl expose deployment/kubernetes-bootcamp --type=\"NodePort\" --port 8080 # 暴露服务\n\n$ kubectl get services\nNAME                  TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\nkubernetes            ClusterIP   10.96.0.1        <none>        443/TCP          5m\nkubernetes-bootcamp   NodePort    10.102.235.226   <none>        8080:32115/TCP   4m\n\n$ kubectl describe services/kubernetes-bootcamp # 查看服务详情\nName:                     kubernetes-bootcamp\nNamespace:                default\nLabels:                   run=kubernetes-bootcamp\nAnnotations:              <none>\nSelector:                 run=kubernetes-bootcamp\nType:                     NodePort\nIP:                       10.102.235.226\nPort:                     <unset>  8080/TCP\nTargetPort:               8080/TCP\nNodePort:                 <unset>  32115/TCP\nEndpoints:                172.18.0.4:8080\nSession Affinity:         None\nExternal Traffic Policy:  Cluster\nEvents:                   <none>\n\n$curl 172.17.0.49:32115 # 服务已经暴露在32115端口\nHello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-5c69669756-hh4k7 | v=1\n```\n\n## 使用 label\n```sh\n$ kubectl describe deployment # 查看服务发布\nName:                   kubernetes-bootcamp\nNamespace:              default\nCreationTimestamp:      Wed, 05 Dec 2018 06:07:06 +0000\nLabels:                 run=kubernetes-bootcamp\nAnnotations:            deployment.kubernetes.io/revision=1\nSelector:               run=kubernetes-bootcamp\nReplicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable\nStrategyType:           RollingUpdate\nMinReadySeconds:        0\nRollingUpdateStrategy:  25% max unavailable, 25% max surge\nPod Template:\n  Labels:  run=kubernetes-bootcamp\n  Containers:\n   kubernetes-bootcamp:\n    Image:        gcr.io/google-samples/kubernetes-bootcamp:v1\n    Port:         8080/TCP\n.\n.\n.\n\n$ kubectl get pods -l run=kubernetes-bootcamp # 只列出某个 label 的 pods\n$ kubectl get services -l run=kubernetes-bootcamp # 只列出某个 label 的 services\n$ kubectl label pod $POD_NAME app=v1 # 给 deployment 改 label\n```\n\n## 删除 services\n```sh\n$ kubectl delete service -l run=kubernetes-bootcamp # 删除 services\n```\n删除 services 只会删除转发，其对应的 pod 还在运行，还可以用 kubectl exec 进行交互\n\n# 扩展应用\n## 扩展发布\n```sh\n$ kubectl scale deployments/kubernetes-bootcamp --replicas=4 # 把 deployment 扩展为4个实例\n\n$ kubectl get deployments\nNAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nkubernetes-bootcamp   4         4         4            4           3m\n\n$ kubectl get pods -o wide\nNAME                                   READY     STATUS    RESTARTS   AGE       IP           NODE\nkubernetes-bootcamp-5c69669756-4lzwf   1/1       Running   0          2m        172.18.0.7   minikube\nkubernetes-bootcamp-5c69669756-hbrb8   1/1       Running   0          3m        172.18.0.3   minikube\nkubernetes-bootcamp-5c69669756-rr92t   1/1       Running   0          2m        172.18.0.6   minikube\nkubernetes-bootcamp-5c69669756-z4ld6   1/1       Running   0          2m        172.18.0.5   minikube\n```\n\n## 缩减发布\n```sh\n$ kubectl scale deployments/kubernetes-bootcamp --replicas=2 # 把 deployment 缩减为2个实例\n```\n\n# 更新应用\n## 替换镜像\n```sh\n$ kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2 # 换镜像\n\n$ kubectl rollout status deployments/kubernetes-bootcamp # 查看新镜像配置状态\ndeployment \"kubernetes-bootcamp\" successfully rolled out\n\n$ kubectl describe pods\nName:           kubernetes-bootcamp-7799cbcb86-prj8w\nNamespace:      default\nNode:           minikube/172.17.0.81\nStart Time:     Wed, 05 Dec 2018 06:33:29 +0000\nLabels:         pod-template-hash=3355767642\n                run=kubernetes-bootcamp\nAnnotations:    <none>\nStatus:         Running\nIP:             172.18.0.9\nControlled By:  ReplicaSet/kubernetes-bootcamp-7799cbcb86\nContainers:\n  kubernetes-bootcamp:\n    Container ID:   docker://76d31785dc318d21ba1c822c64f24c7f58701dfe761d2c1cb8df03002d568732\n    Image:          jocatalin/kubernetes-bootcamp:v2 # 镜像已经替换\n    Image ID:       docker-pullable://jocatalin/kubernetes-bootcamp@sha256:fb1a3ced00cecfc1f83f18ab5cd14199e30adc1b49aa4244f5d65ad3f5feb2a5\n.\n.\n.\n```\n\n## 回滚\n```sh\n$ kubectl rollout undo deployments/kubernetes-bootcamp # 回滚\n```","tags":["运维"]},{"title":"百度地图全国市区商圈和地铁线路","url":"/posts/1542940944/","content":"从百度地图和高德地图中提炼出了对应的接口，方便iOS直接调用。\n\n1.获取全国地铁城市：\n\nhttp://map.baidu.com/?qt=subwayscity&t=123457788\n\n2.根据获取的城市code查询地铁线路详情\n\nhttp://map.baidu.com/?qt=bsi&c=citycode&t=123457788\n\n3.百度地图行政区及商圈接口分析：\n参数： \nqt=sub_area_list  固定参数\next=1  固定参数 \nareacode 地区代码(中国是1，湖北省是15，武汉市是218，武昌区是2788)\nlevel 查询深度 1 2 3\nbusiness_flag 是否查商圈（注意，这个参数只有在areacode为区时查商圈时传1；其它情况传0，否则查询不到数据）\n\n所有 省-市县-区    \nhttp://api.map.baidu.com/shangquan/forward/?qt=sub_area_list&ext=1&level=3&areacode=1&business_flag=0\n\n武汉市的区\nhttp://api.map.baidu.com/shangquan/forward/?qt=sub_area_list&ext=1&level=1&areacode=218&business_flag=0\n\n洪山区的商圈\nhttp://api.map.baidu.com/shangquan/forward/?qt=sub_area_list&ext=1&level=1&areacode=2403&business_flag=1\n\n弊端：\n1.此接口返回的数据始终有一些冗余的热门城市数据。\n2.查商圈的时候返回了商圈的区域坐标，数据量大，废流量。\n3.无法同时返回某个市的所有区的商圈，只能一个区一个区的查询。\n\n高德地图行政区与商圈API分析：\n参数：\nsubdistrict  期望返回多少级下级行政区信息，可选值：0、1、2、3\nkey 申请的数据接口密钥\ns=rsv3  不知道干嘛，不能缺\noutput  返回数据类型，默认是 json ，不传也可以\nkeywords  搜索关键字\n\n武汉市的所有区\nhttp://restapi.amap.com/v3/config/district?subdistrict=2&key=778e8bd7e977163d8b3ded18de20099c&s=rsv3&output=json&keywords=武汉市\n\n高德获取商圈\nhttp://report.amap.com/ajax/districtRank.do?linksType=3&cityCode=110000\n\n--------------------- \n参考资料：  \nhttps://blog.csdn.net/tanqian351/article/details/80509942  \nhttps://blog.csdn.net/qq_912917507/article/details/81085535","tags":["数据"]},{"title":"tar常用命令","url":"/posts/1541569442/","content":"```sh\n$ tar cf etcbak.tar etc/  # 把 etc/ 打包成一个tar\n$ tar xf etcbak.tar -C ./        # 解开一个tar 到当前目录\n$ tar czf etcbak.tar.gz etc/ # 把 etc/ 打包压缩一个 tar\n$ tar zxf etcbak.tar.gz -C ./  # 解压一个tar 到当前目录\n```\n\n- v 显示详情。例如：cvf, zxvf\n- C 指定目录。不加默认当前目录","tags":["常用命令"]},{"title":"unix/linux chmod 权限计算器","url":"/posts/1541565980/","content":"<form name=\"chmod\">\n<table border=\"0\" align=\"center\" cellpadding=\"4\" cellspacing=\"0\" class=\"datatable\" style=\"font:normal 12px Verdana\" ;=\"\">\n    <tbody><tr align=\"LEFT\" valign=\"MIDDLE\"> \n        <td class=\"adHeadline\">Permissions:&nbsp; </td>\n        <td>\n        <input type=\"text\" name=\"t_total\" value=\"751\" size=\"4\" onkeyup=\"octalchange()\">\n        </td>\n        <td>&nbsp; \n        <input type=\"text\" name=\"sym_total\" value=\"\" size=\"12\" readonly=\"1\" style=\"border: 0px none; font-family: &quot;Courier New&quot;, Courier, mono;\">\n        </td>\n    </tr>\n    </tbody>\n</table>\n<br>\n<table border=\"0\" align=\"center\" cellpadding=\"4\" cellspacing=\"0\" class=\"datatable\" style=\"font:normal 12px Verdana\">\n    <tbody><tr bgcolor=\"#009900\"> \n        <td width=\"60\" align=\"left\"> </td>\n        <td width=\"55\" align=\"center\" style=\"color:white\"><b>owner </b></td>\n        <td width=\"55\" align=\"center\" style=\"color:white\"><b>group </b></td>\n        <td width=\"55\" align=\"center\" style=\"color:white\"><b>other </b></td>\n    </tr>\n    <tr bgcolor=\"#dddddd\"> \n        <td width=\"60\" align=\"left\" nowrap=\"\" bgcolor=\"#FFFFFF\">read</td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#EEEEEE\"> \n        <input type=\"checkbox\" name=\"owner4\" value=\"4\" onclick=\"calc_chmod()\">\n        </td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#ffffff\">\n        <input type=\"checkbox\" name=\"group4\" value=\"4\" onclick=\"calc_chmod()\">\n        </td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#EEEEEE\"> \n        <input type=\"checkbox\" name=\"other4\" value=\"4\" onclick=\"calc_chmod()\">\n        </td>\n    </tr>\n    <tr bgcolor=\"#dddddd\"> \n        <td width=\"60\" align=\"left\" nowrap=\"\" bgcolor=\"#FFFFFF\">write</td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#EEEEEE\"> \n        <input type=\"checkbox\" name=\"owner2\" value=\"2\" onclick=\"calc_chmod()\">\n        </td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#ffffff\">\n        <input type=\"checkbox\" name=\"group2\" value=\"2\" onclick=\"calc_chmod()\">\n        </td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#EEEEEE\"> \n        <input type=\"checkbox\" name=\"other2\" value=\"2\" onclick=\"calc_chmod()\">\n        </td>\n    </tr>\n    <tr bgcolor=\"#dddddd\"> \n        <td width=\"60\" align=\"left\" nowrap=\"\" bgcolor=\"#FFFFFF\">execute</td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#EEEEEE\"> \n        <input type=\"checkbox\" name=\"owner1\" value=\"1\" onclick=\"calc_chmod()\">\n        </td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#ffffff\">\n        <input type=\"checkbox\" name=\"group1\" value=\"1\" onclick=\"calc_chmod()\">\n        </td>\n        <td width=\"55\" align=\"center\" bgcolor=\"#EEEEEE\"> \n        <input type=\"checkbox\" name=\"other1\" value=\"1\" onclick=\"calc_chmod()\">\n        </td>\n    </tr>\n    </tbody>\n</table>\n</form>\n\n<script>\nfunction octalchange() \n{\n\tvar val = document.chmod.t_total.value;\n\tvar ownerbin = parseInt(val.charAt(0)).toString(2);\n\twhile (ownerbin.length<3) { ownerbin=\"0\"+ownerbin; };\n\tvar groupbin = parseInt(val.charAt(1)).toString(2);\n\twhile (groupbin.length<3) { groupbin=\"0\"+groupbin; };\n\tvar otherbin = parseInt(val.charAt(2)).toString(2);\n\twhile (otherbin.length<3) { otherbin=\"0\"+otherbin; };\n\tdocument.chmod.owner4.checked = parseInt(ownerbin.charAt(0)); \n\tdocument.chmod.owner2.checked = parseInt(ownerbin.charAt(1));\n\tdocument.chmod.owner1.checked = parseInt(ownerbin.charAt(2));\n\tdocument.chmod.group4.checked = parseInt(groupbin.charAt(0)); \n\tdocument.chmod.group2.checked = parseInt(groupbin.charAt(1));\n\tdocument.chmod.group1.checked = parseInt(groupbin.charAt(2));\n\tdocument.chmod.other4.checked = parseInt(otherbin.charAt(0)); \n\tdocument.chmod.other2.checked = parseInt(otherbin.charAt(1));\n\tdocument.chmod.other1.checked = parseInt(otherbin.charAt(2));\n\tcalc_chmod(1);\n};\n\nfunction calc_chmod(nototals)\n{\n  var users = new Array(\"owner\", \"group\", \"other\");\n  var totals = new Array(\"\",\"\",\"\");\n  var syms = new Array(\"\",\"\",\"\");\n\n\tfor (var i=0; i<users.length; i++)\n\t{\n\t  var user=users[i];\n\t\tvar field4 = user + \"4\";\n\t\tvar field2 = user + \"2\";\n\t\tvar field1 = user + \"1\";\n\t\t//var total = \"t_\" + user;\n\t\tvar symbolic = \"sym_\" + user;\n\t\tvar number = 0;\n\t\tvar sym_string = \"\";\n\t\n\t\tif (document.chmod[field4].checked == true) { number += 4; }\n\t\tif (document.chmod[field2].checked == true) { number += 2; }\n\t\tif (document.chmod[field1].checked == true) { number += 1; }\n\t\n\t\tif (document.chmod[field4].checked == true) {\n\t\t\tsym_string += \"r\";\n\t\t} else {\n\t\t\tsym_string += \"-\";\n\t\t}\n\t\tif (document.chmod[field2].checked == true) {\n\t\t\tsym_string += \"w\";\n\t\t} else {\n\t\t\tsym_string += \"-\";\n\t\t}\n\t\tif (document.chmod[field1].checked == true) {\n\t\t\tsym_string += \"x\";\n\t\t} else {\n\t\t\tsym_string += \"-\";\n\t\t}\n\t\n\t\t//if (number == 0) { number = \"\"; }\n\t  //document.chmod[total].value = \n\t\ttotals[i] = totals[i]+number;\n\t\tsyms[i] =  syms[i]+sym_string;\n\t\n  };\n\tif (!nototals) document.chmod.t_total.value = totals[0] + totals[1] + totals[2];\n\tdocument.chmod.sym_total.value = \"-\" + syms[0] + syms[1] + syms[2];\n}\n</script>\n\n--------------------------------------\n在UNIX系统家族里，文件或目录权限的控制分别以读取（Read)，写入(Write)，执行(Execute)3种一般权限来区分，另有3种特殊权限可供运用，再搭配拥有者与所属群组管理权限范围。您可以使用CHMOD指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果您对符号连接修改权限，其改变会作用在被连接的原始文件。权限范围的表示法如下：\n- u：User，即文件或目录的拥有者。\n- g：Group，即文件或目录的所属群组。\n- o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。\n- a：All，即全部的用户，包含拥有者，所属群组以及其他用户。\n- 有关权限代号的部分，列表如下：\n- r：读取权限，数字代号为“40”\n- w：写入权限，数字代号为“2”\n- x：执行或切换权限，数字代号为“10”\n- -：不具任何权限，数字代号为“0”\n\n--------------------------------------\n转自：http://mistupid.com/internet/chmod.htm","tags":["在线工具"]},{"title":"推荐我的结巴分词http服务","url":"/posts/1540123748/","content":"[结巴分词](https://github.com/fxsjy/jieba)是一个非常好用的分词组件。但是只支持 python 语言。其他语言想要使用的话，只能使用第三方开发的版本。由于第三方的版本不是没有实现全部功能，就是文档不全，不然就是版本落后，非要使用的话，其实不是特别有安全感。\n\n鉴于结巴分词的接口非常简单，常用的函数只有4个，于是我用 Flask 实现了一个分词的 http 服务，地址在 [jiebahttp](https://github.com/questionlin/jiebahttp)。提供下面4个接口：\n```\n/cut?sentence=&cut_all=&HMM=\n/cut_for_search?sentence=&HMM=\n/posseg_cut?sentence=&HMM=\n/tokenize?sentence=&mode=&HMM\n```\n分别对应结巴的 cut, cut_for_search, posseg.cut, tokenize 4 个函数。同时支持 GET 和 POST 请求。有了 jiebahttp，其他语言就不用引入不放心的第三方库，也能方便的使用了。\n\n题外话，Elastic Stack 和 MongoDB 的成功早就告诉我们，一个开源库想要真正好用，不能依赖第三方来实现跨语言版本，而是要自己实现远程调用服务。","tags":["安利"]},{"title":"SQL用join还是分多次查询","url":"/posts/1539158031/","content":"这是一个老生常谈的问题了，大家都知道 join 表太多不好，阿里的规范里提到不可以 join 超过3个表。这篇文章通过例子探讨下3个表以内应该用 join 还是多次查询。先说结论，推荐使用 join 语句。\n\n首先打开 mysql 的计时功能\n```sql\nmysql> set profiling = 1;\nmysql> show variables like \"%pro%\";\n+------------------------------------------+-------+\n| Variable_name                            | Value |\n+------------------------------------------+-------+\n| check_proxy_users                        | OFF   |\n| have_profiling                           | YES   |\n| mysql_native_password_proxy_users        | OFF   |\n| performance_schema_max_program_instances | -1    |\n| profiling                                | ON    |\n| profiling_history_size                   | 15    |\n| protocol_version                         | 10    |\n| proxy_user                               |       |\n| sha256_password_proxy_users              | OFF   |\n| slave_compressed_protocol                | OFF   |\n| stored_program_cache                     | 256   |\n+------------------------------------------+-------+\n```\n确保 profiling 值为 ON\n\n现在查2000条数据，获得合并查询的时间\n```sql\nmysql> select * from report_order left join order_form on report_order.order_id = order_form.order_id limit 2000;\n```\n\n然后分开查询\n```sql\nmysql> select * from report_order limit 2000;\nmysql> select * from order_form where order_id in (123,123...);\n```\n\n然后查看时间\n```sql\nmysql> show profiles;\n+----------+------------+-------------------------------------------------------------------------------------------------------------------+\n| Query_ID | Duration   | Query                                                                                                             |\n+----------+------------+-------------------------------------------------------------------------------------------------------------------+\n|        7 | 0.05155450 | select * from report_order left join order_form on report_order.order_id = order_form.order_id limit 2000         |\n|        8 | 0.01129025 | select * from report_order limit 2000                                                                             |\n|        9 | 0.08883325 | select * from order_form where order_id in (123,234,345....)                                                      |\n|       10 | 0.00051300 | select * from order_form where order_id = '123123'                                                                |\n+----------+------------+-------------------------------------------------------------------------------------------------------------------+\n```\n\n可以看到，使用 join 的语句7耗时小于多次查询的语句8+9之和，因此在 join 表不多的情况下推荐使用 join。\n\n另外，对于应该使用 in 还是多次查询的问题，可以看到使用 in 的语句9耗时远远小于不使用的语句10*2000，因此推荐使用 in。","tags":["mysql"]},{"title":"http2与服务端配置","url":"/posts/1538191275/","content":"# http2 与 http1 的主要区别\n在于一下几点：\n- http2 使用一小块一小块的二进制帧传输\n- http2 文件可以设置优先级\n- http2 header 部分会被压缩\n- http2 服务端可以主动推送文件\n\n# 服务端配置\n## nginx 配置\nhttp2 要求服务器支持 https，在之前的文章[《HTTPS服务器配置》](/posts/1528164470)中已经介绍了怎么配置 https，下面给一个比较常用的 nginx http2 配置\n```nginx\n# http 跳转到 https\nserver {\n    listen         80;\n    listen    [::]:80;\n    server_name    example.com;\n    return         301 https://$server_name$request_uri;\n}\n\nserver {\n    # 在这里加上 http2 就可以开启 http2 支持\n    listen 443 ssl http2 default_server;\n    listen [::]:443 ssl http2 default_server;\n\n    server_name example.com;\n\n    ssl_certificate /etc/nginx/ssl/example.com.crt;\n    ssl_certificate_key /etc/nginx/ssl/example.com.key;\n    ssl_session_timeout  5m;\n\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers   on;\n\n    location / {\n        try_files $uri $uri/ =404;\n\n        root /var/www/html;\n        index index.html index.htm index.nginx-debian.html;\n\n        # 这里是服务端推送文件配置，如果没有文件需要推送，可以不加\n        http2_push /style.css;\n        http2_push /example.png;\n    }\n}\n```\n\n## PHP 服务端推送\n推送文件是要经常改动的，但我们又不希望经常改动 nginx 配置文件，这时候可以通过后端程序实现。做法是在 http \b头部添加 link 字段：\n> Link: </styles.css>; rel=preload; as=style\n> Link: </example.png>; rel=preload; as=image\n\n对应的 PHP 代码是：\n```php\n<?php\nheader(\"Link: <{$uri}>; rel=preload; as=image\",false);\n```\n\n相应 nginx 配置添加\n```nginx\nserver {\n    listen 443 ssl http2;\n    # ...\n    location = / {\n        http2_push_preload on;\n        # nginx 接 swoole 时需要加这行转发，接 php-fpm 时不需要\n        proxy_pass http://upstream;\n    }\n}\n```\n\n\n\n各种语言可以参考 [Go](https://ops.tips/blog/nginx-http2-server-push/), [Node](https://blog.risingstack.com/node-js-http-2-push/), [PHP](https://blog.cloudflare.com/using-http-2-server-push-with-php/) 的实现示范。\n\n----------------------\n参考资料：  \nnginx容器教程：http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html  \nHow To Set Up Nginx with HTTP/2 Support on Ubuntu 16.04：https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-with-http-2-support-on-ubuntu-16-04  \nUsing HTTP/2 Server Push with PHP：https://blog.cloudflare.com/using-http-2-server-push-with-php/  \nHTTP/2 服务器推送（Server Push）教程：http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html","tags":["http"]},{"title":"用PHP做爬虫的正确姿势","url":"/posts/1538110935/","content":"之前写过一篇[《用python做爬虫的正确姿势》](/posts/1529320519)。但我用 python 还不是那么顺手，这篇文章介绍下 php 爬虫的最佳实践。\n\n一个爬虫程序至少需要抓取和解析两个部分，抓取部分我使用的是 [guzzle](https://github.com/guzzle/guzzle)。特点也是封装了会话（session），自动更新 cookies。\n\n解析我使用的是 [dom-crawler](https://github.com/symfony/dom-crawler)。语法类似 jQuery，上手比较快。在浏览器 console 里复制元素的 css 选择器或者 xpath 路径，粘贴到代码里即可。这里要注意浏览器会给选择器添加元素，例如 tbody，复制出来是 table > tbody > tr。但其实 html 里没有 tbody 这个元素。手动去掉就好了。\n\ndom-crawler 来自 php 宝库 symfony，底层依赖他们的另一个库 [css-selector](https://github.com/symfony/css-selector)，可以将 css 选择器转换成 xpath 路径。如果你只需要找到元素，那么把 xpath 传给 [DOMXPath](https://secure.php.net/manual/en/class.domxpath.php) 或 [SimpleXMLElement](https://secure.php.net/manual/en/class.simplexmlelement.php) 这两个扩展可以更快。\n\n以下是不能使用的 css 选择器：\n- 链接状态: :link, :visited, :target\n- 用户行为: :hover, :focus, :active\n- UI 状态: :invalid, :indeterminate (但是， :enabled, :disabled, :checked 和 :unchecked 是可用的)\n- 伪元素: (:before, :after, :first-line, :first-letter)\n- 带星号的: \\*:first-of-type, \\*:last-of-type, \\*:nth-of-type, \\*:nth-last-of-type, \\*:only-of-type. (带元素名是可以的 (例如 li:first-of-type) 但带 \\* 的不行.","tags":["php"]},{"title":"git子模块","url":"/posts/1537840874/","content":"大多数现在语言都有自己的包管理器，比如 php 的 composer，和 nodejs 的 npm。但是如果语言没有包管理器，或者想要的库没有打包，又不想手动更新，该怎么办呢？答案是 git 子模块。下面来一步一步建一个子模块。\n\n# 添加子模块\n```sh\n# 首先建一个仓库\n$ mkdir ljj_test\n$ cd ljj_test\n$ git init\n\n# 添加一个子模块\n$ git submodule add https://github.com/questionlin/php-view.git\nCloning into '/Users/simonlin/Documents/workshop/ljj_test/php-view'...\nremote: Enumerating objects: 46, done.\nremote: Total 46 (delta 0), reused 0 (delta 0), pack-reused 46\nUnpacking objects: 100% (46/46), done.\n\n# 查看一下\n$ git status\nOn branch master\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n\tnew file:   .gitmodules\n\tnew file:   php-view\n```\n这时目录下会多出我们的子模块 php-view 和一个 .gitmodules 文件，这个文件里保存了子模块的映射关系。**这个操作在子目录下也可行。**\n\n# 使用子模块\n## 下载子模块\n```sh\n# 进入到 git 仓库目录\n$ cd ljj_test\n$ git submodule init\n# 下载文件\n$ git submodule update\n\n# 或者也可以用命令\n$ git clone --recursive https://github.com/chaconinc/MainProject\n```\n\n## 切换分支\n```sh\n$ git config -f .gitmodules submodule.php-view.branch (branch name)\n```\n\n## 更新\n```sh\n$ git submodule update --remote (module name)\n```\n这个命令会更新所有子模块，如果只想更新特定子模块，后面加上子模块名称\n\n## 删除子模块\n删除子模块的代码，然后删除 .gitmodules 里面的相关信息。\n\n----------------------------------\n参考资料：  \nhttps://git-scm.com/book/zh/v2/Git-工具-子模块","tags":["git"]},{"title":"手把手做一个php扩展","url":"/posts/1537782733/","content":"# 搭建环境\n首先确保你本地有 php 环境。然后下载 php 源码。\n\n```sh\n# 其实只需要里面的几个文件，所以下载 zip 包也行。\n$ git clone https://github.com/php/php-src.git\n$ cd php-src/ext\n# 用模版新建一个项目，名为 rjson\n$ ./ext_skel.php --ext rjson\n$ cd rjson\n$ phpize\n$ ./configure --with-php-config=/usr/local/bin/php-config\n$ make\n$ make test\n$ make install\n```\n\n现在 rjson.so 已经在扩展目录下了，需要在 php.ini 最底部加上\n\n```\nextension=rjson.so\n```\n\n看看扩展加载了没有\n\n```sh\n$ php -m | grep rjson\nrjson\n```\n\n新建一个文件 a.php\n```php\n<?php\necho rjson_test2('ljj');\n```\n执行看看\n```sh\n$ php a.php\nHello ljj\n```\n我们看到模版自带的测试函数已经可以执行了\n\n# 开始编写\n打开文件 rjson.c，可以找到 rjson_test1 和 rjson_test2 的定义。我们照着写一个 rjson_test3\n```c\n// 在下面这个数组里增加一行，第二个参数是函数参数的定义，这里省略\nstatic const zend_function_entry rjson_functions[] = {\n    PHP_FE(rjson_test3,     NULL)\n}\n\n// 最外层增加rjson_test3，可以写在 rjson_test2 后面\nPHP_FUNCTION(rjson_test3)\n{\n\tzend_string *retval;\n\tretval = strpprintf(0, \"I'm %s\", \"ljj\");\n\tRETURN_STR(retval);\n}\n```\n然后再 make install\n\n修改 a.php\n```php\necho rjson_test3();\n```\n执行\n```\n$ php a.php\nI'm ljj\n```\n到此，一个没有参数的函数就完成了。写 php 扩展的时候要用到很多 php 自己定义的 c 函数或者宏指令。比如 RETURN_STR() 不能返回 char*，只能返回 zend_string*。这些地方参考《PHP7内核剖析》。\n\n-------------------------------\n参考资料：  \nmac 系统下开发一个PHP扩展：https://blog.csdn.net/imbibi/article/details/79354464  \n用C/C++扩展你的PHP：http://www.laruence.com/2009/04/28/719.html  \n《PHP7内核剖析》","tags":["php"]},{"title":"机器学习获得的两种结果及其用法","url":"/posts/1537430575/","content":"# 第一种结果——label\n先来回顾一下[上一篇文章](/posts/1537256287)，文章中我们获得了三个特征：\n1. 用户特征\n2. 广告特征\n3. 用户和广告的关系表\n\n我们使用CountVectorizer，OneHotEncoder，LabelEncoder，将所有特征压成一个\b list，然后使用 lightGBM 模型来训练\n```python\nimport lightgbm as lgb\nclf = lgb.LGBMClassifier(\n    boosting_type='gbdt', num_leaves=31, reg_alpha=0.0, reg_lambda=1,\n    max_depth=-1, n_estimators=1500, objective='binary',\n    subsample=0.7, colsample_bytree=0.7, subsample_freq=1,\n    learning_rate=0.05, min_child_weight=50, random_state=2018, n_jobs=-1\n)\nclf.fit(train_x, train_y, eval_set=[(train_x, train_y)], eval_metric='auc',early_stopping_rounds=100)\n\nlabel = clf.predict(test_x)\n```\n最后得到的 label 是一个包含-1\b或1的 list。在生产环境中我们会不断的扫描新用户和新广告的特征，提取后用这个模型预测，把结果中为1的广告(aid)保存下来，最后投放给对应的用户(uid)。这是机器学习中一般的结果。\n\n# 第二种结果——特征本身\n在参考资料 elasticsearch-spark-recommender 中，作者介绍了如何用 elasticsearch 和 spark 来做协同过滤推荐系统。\b例子有两个特征：\n1. 电影特征（年份、类型）\n2. 用户对电影的打分\n\n例子中用 spark 提供的最小二乘机来训练模型，然后把得到的特征数组合并成字符串保存到 elasticsearch 中（文章里介绍了把spark 读写 es 的插件）\n\n```python\nfrom pyspark.ml.recommendation import ALS\nfrom pyspark.sql.functions import col\n# 训练\nals = ALS(userCol=\"userId\", itemCol=\"movieId\", ratingCol=\"rating\", regParam=0.01, rank=20, seed=12)\nmodel = als.fit(ratings_from_es)\n```\n\n每个电影的 document 中会多一行\n```\nvector: '1.0348|2.329487|8.3456435|5.293874'\n```\n当用户打开一个电影的网页，系统得到这部电影的特征 vector，然后输入 elasticsearch 进行搜索，es 会以'|'分隔字符串，然后无序匹配，得到匹配数字（其实是字符串）最多的电影返回给用户。这样一个协同过滤推荐系统就完成了。\n\n----------------------------------\n参考资料：  \nMachine-Learning：https://github.com/Jack-Cherish/Machine-Learning  \nelasticsearch-spark-recommender：https://github.com/IBM/elasticsearch-spark-recommender","tags":["机器学习"]},{"title":"MySQL的in条件与锁表","url":"/posts/1537425757/","content":"MySQL 在 select 的时候，如果 where 里面有 in 条件的话，系统会判断范围会不会太大，如果太大的话，则会跳过索引，直接查表。而影响这个范围的参数，就是 eq_range_index_dive_limit。\n\n这本来没什么，预估到，或者在生产环境遇到慢查询的时候，再优化这个参数和 sql 即可。**可是，innodb 的锁是加在索引上的。当 update 的时候，如果系统也跳过索引，就会把锁加在主键上，造成锁表。**下面是一个例子。\n\n```mysql\nmysql> select * from t;\n+----+------+------+\n| a  | b    | c    |\n+----+------+------+\n|  0 |    0 |    0 |\n|  1 |    1 |    1 |\n|  3 |    3 |    1 |\n|  5 |    5 |    1 |\n|  7 |    7 |    1 |\n|  9 |    9 |    0 |\n| 10 |   10 |    0 |\n+----+------+------+\n\nmysql> explain select c from t where b in (3,5);\n+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+\n| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                 |\n+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+\n|  1 | SIMPLE      | t     | NULL       | range | b             | b    | 5       | NULL |    2 |   100.00 | Using index condition |\n+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+\n\nmysql> explain update t set c=1 where b in(3,5);\n+----+-------------+-------+------------+-------+---------------+------+---------+-------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref   | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+------+---------+-------+------+----------+-------------+\n|  1 | UPDATE      | t     | NULL       | range | b             | b    | 5       | const |    2 |   100.00 | Using where |\n+----+-------------+-------+------------+-------+---------------+------+---------+-------+------+----------+-------------+\n```\n当 b 的范围是 (3,5) 的时候，select 和 update 都使用了b 这个索引。\n\n```mysql\nmysql> explain select c from t where b in (3,5,7);\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | t     | NULL       | ALL  | b             | NULL | NULL    | NULL |    7 |    42.86 | Using where |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n\nmysql> explain update t set c=1 where b in(3,5,7);\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n|  1 | UPDATE      | t     | NULL       | index | b             | PRIMARY | 4       | NULL |    7 |   100.00 | Using where |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n```\n当 b 的范围是 (3,5,7) 的时候，select 没有使用索引，直接查表。update 使用了主键。\n\n如果这里\n```sql\nupdate t set c=1 where b in (3,5,7);\n```\n是一个事务，同时开另一个事务\n```sql\nupdate t set c=1 where a=0;\n```\n这时第一个 sql 会锁表，第二个 sql 就会进入等待。注意这里还不是 gap lock 的情况。\n\n\n--------------------------------\n参考：  \n简述 mysql 的 eq_range_index_dive_limit 参数作用：https://blog.csdn.net/java_zone/article/details/53383876","tags":["mysql"]},{"title":"特征工程初探","url":"/posts/1537256287/","content":"# 数据原型\n广告特征 adFeature.csv\n```python\n    aid  advertiserId  campaignId  creativeId  creativeSize  adCategoryId  \\\n0   177          8203       76104     1500666            59           282   \n1  2050         19441      178687      245165            53             1   \n2  1716          5552      158101     1080850            35            27   \n3   336           370        4833      119845            22            67   \n4   671         45705      352827      660519            42            67   \n\n   productId  productType  \n0          0            6  \n1          0            6  \n2        113            9  \n3        113            9  \n4          0            4\n```\n\n用户特征 user_feature_sample.csv\n```python\n   Unnamed: 0    LBS  age appIdAction appIdInstall  carrier  \\\n0           0  950.0    4         NaN          NaN        1   \n1           1  803.0    2         NaN          NaN        1   \n2           2  927.0    1         NaN          NaN        3   \n3           3  486.0    4         NaN          NaN        3   \n4           4  112.0    5         NaN          NaN        3   \n\n   consumptionAbility       ct  education  gender    ...     \\\n0                   2      3 1          7       2    ...      \n1                   1      3 1          2       1    ...      \n2                   1      3 1          5       1    ...      \n3                   1      1 3          7       1    ...      \n4                   2  3 1 4 2          6       1    ...      \n\n                                           interest5  \\\n0  52 100 72 131 116 11 71 12 8 113 28 73 6 132 9...   \n1                                                NaN   \n2  77 72 80 116 101 13 1 109 8 50 6 42 76 9 46 36...   \n3  100 80 92 37 116 13 47 4 71 8 50 28 98 115 6 4...   \n4        131 116 13 8 6 132 42 9 59 18 58 64 129 103   \n\n                                  kw1                             kw2  kw3  \\\n0  664359 276966 734911 103617 562294  11395 79112 115065 77033 36176  NaN   \n1  338851 361151 542834 496283 229952     80263 39618 53539 180 38163  NaN   \n2  746140 695808 126355 771775 411511  105115 71378 41409 74061 44005  NaN   \n3   283399 402245 734509 654027 32061  74010 32918 67882 116802 20957  NaN   \n4  562294 157603 589706 657719 495672   62764 97803 89066 55545 74061  NaN   \n\n  marriageStatus   os                    topic1                    topic2  \\\n0             11    2   9826 105 8525 5488 7281  9708 5553 6745 7477 7150   \n1           5 13    1  4391 9140 5669 1348 4388  9401 7724 1380 8890 7153   \n2          13 10    1  1502 5488 9826 2187 8088  5005 9154 2756 5612 4209   \n3             11  1 2  1619 7342 3064 9213 8525   810 2438 5659 1844 9262   \n4             11    1    477 9826 5808 644 2747  5483 2199 5424 1511 7751   \n\n  topic3       uid  \n0    NaN  26325489  \n1    NaN   1184123  \n2    NaN  76072711  \n3    NaN  63071413  \n4    NaN  81294159  \n```\n用户特征里出现了空值 NaN，以及用空格分开的一对多的值，在下一段介绍怎么处理\n\n用户-广告关系 train.csv\n```python\n    aid       uid  label\n0   699  78508957     -1\n1  1991   3637295     -1\n2  1119  19229018     -1\n3  2013  79277120     -1\n4   692  41528441     -1\n```\n\n# 特征提取\n代码参考的是参考资料里的 baseline 的代码，稍做改动\n```python\nimport pandas as pd\nimport numpy as np\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.preprocessing import OneHotEncoder,LabelEncoder\nfrom scipy import sparse\n\nuser_feature.fillna('-1')\ndata = pd.merge(train, ad_feature, on='aid', how='left')\ndata = pd.merge(data, user_feature, on='uid', how='left')\ndata.dropna()\n\n# 只有数字的数据适合用 one hot\none_hot_feature=['LBS','age','carrier','consumptionAbility','education','gender','house','os','ct','marriageStatus','advertiserId','campaignId', 'creativeId','adCategoryId', 'productId', 'productType']\n# 这些是关系型的数据，是用空格分开的数字，可以用词向量来处理\nvector_feature=['appIdAction','appIdInstall','interest1','interest2','interest3','interest4','interest5','kw1','kw2','kw3','topic1','topic2','topic3']\n\nfor f in one_hot_feature:\n    data[f] = LabelEncoder().fit_transform(data[f])\n\ntrain_x=train[['creativeSize']]\ntest_x=train[['creativeSize']]\nfor f in one_hot_feature:\n    enc.fit(data[f].values.reshape(-1,1))\n    train_a = enc.transform(train[f].values.reshape(-1,1))\n    train_x = sparse.hstack((train_x, train_a))\n\ncv = CountVectorizer()\nfor f in vector_feature:\n    cv.fit(data[f])\n    train_a=cv.trainsform(data[f])\n    train_x=sparse.hstack((train_x, train_a))\n```\n## 数字的特征提取\n对于纯数字的特征，要先 LabelEncoder().fit_transform() 后再 OneHotEncoder().fit_transform()。\n\nLanbelEncoder 会给值重新赋值，这样可以忽略值的大小。例如\n```python\nIn [3]: LabelEncoder().fit_transform([111,0.2,3000,42,25])\nOut[3]: array([3, 0, 4, 2, 1])\n```\n\n## 关系的特征提取\n用户特征分为三层\n1. 第一层是广告和用户的信息\n2. 第二层是广告和用户的关系，这里用pd.merge 合并成一个二维数组\n3. 第三层是用户和其他信息的关系，是字符串格式，内容是用空格隔开的数字，被当成单词后会按词向量处理，即忽略顺序。\n\n第三层处理完后用 sparse.hstack 压成一个二维数组，就成了最终训练用的特征。\n\n## 特殊的关系特征\n用户特征里面有一类\n```python\n['os','ct']\n```\n这类值是用空格隔开的数字，但是数字只有1位。例子里用 LabelEncoder，会被当成整个字符串，显然不合适。用 CountVectorizer 则会报\n```python\nValueError: empty vocabulary; perhaps the documents only contain stop words\n```\n我的做法是去掉空格（不去也一样）后用 CountVectorizer(analyzer='char')\n\n## 关系的数量\n关系特征里面还有一项是数量，比如 interest1，有些人只有一个，有些人有很多，更高分的选手把这项也计算出来作为特征。\n\n----------------------------------\n参考资料：  \n2018腾讯广告算法大赛baseline：https://github.com/YouChouNoBB/2018-tencent-ad-competition-baseline","tags":["机器学习"]},{"title":"sql的引号与索引","url":"/posts/1536648139/","content":"**先说结论，sql 的 where 值部分，都要加上引号。**即 where a=x 改成 where a='x'。\n\n当列类型是数字时，不管值加不加引号，都会走索引。但如果列类型是字符串时，如果不加引号，就不会走索引。字符串不加引号的情况一般不会出现，以下情况会出现：某一列一开始打算用来存放字符串，但实际上存放的都是数字，久而久之开发人员以为此列就是用来存放数字，便不加引号。","tags":["mysql"]},{"title":"豆瓣API","url":"/posts/1535854293/","content":"# 图书\n## 搜索图书\nGET  https://api.douban.com/v2/book/search\n\n参数 | 意义 | 备注\n-|-|-\nq | 查询关键字 | q和tag必传其一\ntag | 查询的tag | q和tag必传其一\nstart | 取结果的offset | 默认为0\ncount | 取结果的条数 | 默认为20，最大为100\n\n返回：返回status=200\n\n```json\n{\n      \"start\": 0,\n      \"count\": 10,\n      \"total\": 30,\n      \"books\" : [Book, ]\n    }\n注：对于登录用户，若搜索结果图书在当前用户的图书收藏中，会在对应搜索结果信息中附加当前用户对此书的收藏信息，改部分的 Book 数据结构如下：\n\n{\n    … (图书信息的其他部分)\n    \"current_user_collection\": {\n        \"status\":\"read\",\n        \"rating\": {\n            \"max\":5,\n            \"value\":\"5\",\n            \"min\":0\n        },\n        \"updated\":\"2012-11-2012:08:04\",\n        \"user_id\":\"33388491\",\n        \"book_id\":\"6548683\",\n        \"id\":605519800\n    }\n}\n```\n## 根据 id 获取图书信息\nGET  https://api.douban.com/v2/book/:id\n\n返回图书信息，返回status=200\n\n对于授权用户，返回数据中会带有该用户对该图书的收藏信息：\n```json\n{\n    … (图书信息的其他部分)\n    \"current_user_collection\": {\n        \"status\":\"read\",\n        \"rating\": {\n            \"max\":5,\n            \"value\":\"5\",\n            \"min\":0\n        },\n        \"updated\":\"2012-11-2012:08:04\",\n        \"user_id\":\"33388491\",\n        \"book_id\":\"6548683\",\n        \"id\":605519800\n    }\n}\n```\n\n## 通过 isbn 获取图书信息\nGET  https://api.douban.com/v2/book/:isbn\n\n# 电影\n## 搜索电影\nGET https://api.douban.com/v2/movie/search?q=张艺谋\n\n参数 | 描述 | 备注\n-|-|-\nq | 关键词 | q和tag必传其一\ntag | tag | q和tag必传其一\nstart | start | 0\ncount | count | -\n\n## 通过 id 获取电影\nGET https://api.douban.com/v2/movie/25849049\n\n## 通过 imdb 获取电影\nGET https://api.douban.com/v2/movie/imdb/:imdb\n\n# 音乐\n## 搜索音乐\nGET  https://api.douban.com/v2/music/search\n\n参数 | 描述 | 备注\n-|-|-\nq | 查询关键字 | q和tag必传其一\ntag | 查询的tag | q和tag必传其一\nstart | 取结果的offset | 默认为0\ncount | 取结果的条数 | -\n\n返回：返回status=200，\n```json\n{\n    \"start\": 0,\n    \"count\": 10,\n    \"total\": 30,\n    \"musics\" : [Music, ]\n}\n```\n\n## 获取音乐信息\nGET  https://api.douban.com/v2/music/:id\n\n返回音乐信息，返回status=200\n\n------------------------------\n参考：  \n豆瓣官方客户端：https://github.com/douban/douban-client","tags":["数据"]},{"title":"redis搭建集群","url":"/posts/1535610189/","content":"# 集群与主从的区别\n主从模式中，客户端可以从任何一个服务端读取，分散了读的压力，但是只能对特定的一个服务端做写操作。redis 提供了 sentinel 模式监控主服务的状态，如果主服务挂了，会选择一台从服务作为主服务。可是如果住服务是因为写压力过大，那么相同配置的从服务被选为主之后，毫无疑问也会因为压力太大而挂掉。而且 redis 所有数据都是保存在内存里，如果数据太多，一台服务器放满了，也不能用主从模式。这个时候可以用集群方案来解决。\n\nredis 集群方案里，系统由多个主从服务组成，每个服务端都可以读写，服务端会根据哈希算法，分配数据到特定的服务器上。系统内不再有单点压力。\n\n# 过一遍官方例子\n## 在官网下载源码后编译\n```sh\n$ gem install redis # 安装 ruby 依赖\n$ wget http://download.redis.io/releases/redis-4.0.11.tar.gz\n$ tar xzf redis-4.0.11.tar.gz\n$ cd redis-4.0.11\n$ make\n```\n这里确保 src/redis-server, src/redis-cli 两个生成成功。然后进入 utils/create-cluster，执行\n```sh\n$ ./create-cluster start #生成6个实例\n$ ./create-cluster create #将6个实例配置为集群\n```\n\n## 用客户端测试集群\n官方例子生成了6个实例，分别使用 30001-30006 6个端口。\n\n开一个客户端，连接第一个端口\n```sh\n$ redis-cli -c -p 30001\n127.0.0.1:30001> set ljj 1\nOK\n```\n开另一个客户端，连接第二个端口\n```sh\n$ redis-cli -c -p 30002\n127.0.0.1:30002> get ljj\n-> Redirected to slot [1799] located at 127.0.0.1:30001\n\"1\"\n127.0.0.1:30001> get ljj\n\"1\"\n127.0.0.1:30001> set ljj2 2\nOK\n```\n这里发现客户端已经被转到了30001这个端口。之后用客户端分别连接每个端口，执行 get 和 set 操作，发现 **在任何一个客户端都是可以执行set 和 get 操作的，系统会\b判断值应该被存储在哪个服务，然后转接过去**。\n\n## 最后清理现场\n```sh\n$ ./create-cluster stop #停止所有实例\n$ ./create-cluster clean #删除所有生成的文件\n```\n\n# 手动生成集群\n## 生成实例\n先来分析一下 create-cluster 的代码。当执行 start 的时候，实际上是执行了\n```sh\nredis-server --port $PORT --cluster-enabled yes --cluster-config-file nodes-${PORT}.conf --cluster-node-timeout 2000 --appendonly yes --appendfilename appendonly-${PORT}.aof --dbfilename dump-${PORT}.rdb --logfile ${PORT}.log --daemonize yes\n```\n$PORT 是30001-30006。如果目录下没有 nodes-${PORT}.conf 配置文件，redis 会自己生成一个，并写入信息。现在先手动生成实例 30001-30004。\n```sh\n$ ps aux | grep redis\nsimon            52453   0.1  0.1  4301948   2232   ??  Ss   11:21上午   0:00.08 ../../src/redis-server *:30001 [cluster]\nsimon            52474   0.1  0.1  4301948   2208   ??  Ss   11:21上午   0:00.02 ../../src/redis-server *:30004 [cluster]\nsimon            52472   0.1  0.1  4310140   2256   ??  Ss   11:21上午   0:00.03 ../../src/redis-server *:30003 [cluster]\nsimon            52470   0.1  0.1  4301948   2204   ??  Ss   11:21上午   0:00.04 ../../src/redis-server *:30002 [cluster]\nsimon            52476   0.0  0.0  4267752    876 s001  S+   11:22上午   0:00.00 grep redis\n```\n## 连接各节点\n只要连接并操作一个一个服务端即可\n```sh\n127.0.0.1:30001> CLUSTER MEET 127.0.0.1 30002\nOK\n127.0.0.1:30001> CLUSTER MEET 127.0.0.1 30003\nOK\n127.0.0.1:30001> CLUSTER MEET 127.0.0.1 30004\nOK\n```\n\n## 查看集群状态\n查看集群状态\n```sh\n127.0.0.1:30001> cluster info\ncluster_state:fail\ncluster_slots_assigned:0\ncluster_slots_ok:0\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:4\ncluster_size:0\ncluster_current_epoch:3\ncluster_my_epoch:1\ncluster_stats_messages_ping_sent:213\ncluster_stats_messages_pong_sent:213\ncluster_stats_messages_meet_sent:3\ncluster_stats_messages_sent:429\ncluster_stats_messages_ping_received:213\ncluster_stats_messages_pong_received:216\ncluster_stats_messages_received:429\n```\n\n查看集群内所有节点\n```sh\n127.0.0.1:30001> cluster nodes\n735e799f68bf21aa6af679a55f28f69740e2251a 127.0.0.1:30004@40004 master - 0 1535779344092 3 connected\n69a812b0dfc02dee94bd03a8e1ff453728409e5a 127.0.0.1:30001@40001 myself,master - 0 1535779343000 1 connected 0-8192\nb2897dbc560a9774018559d49eb277ae75bd685b 127.0.0.1:30003@40003 master - 0 1535779343790 0 connected 8193-16383\nac391224d51ccd316809f88e2d59b645213a1e66 127.0.0.1:30002@40002 master - 0 1535779343790 2 connected\n```\n\n## 分配哈希槽\nredis集群有16384个哈希槽，要把所有数据映射到16384槽，需要批量设置槽\n```sh\nredis-cli -p 30001 cluster addslots {0..8192}\nredis-cli -p 30003 cluster addslots {8193..16383}\n```\n\n## 做主从映射\n我的配置是 30001主->30002从，30003主->30004从\n```sh\n127.0.0.1:30002> CLUSTER REPLICATE 69a812b0dfc02dee94bd03a8e1ff453728409e5a\n127.0.0.1:30004> CLUSTER REPLICATE b2897dbc560a9774018559d49eb277ae75bd685b\n```\n\n## 总结\n到此 redis 集群已经搭建好了。现在执行 cluster info，cluster_state 已经是 ok 了。\n\n看得出还是挺麻烦的，推荐使用官方的脚本 redis-trib.rb。当执行 create-cluster create 的时候，是执行了\n```sh\n../../src/redis-trib.rb create --replicas 1 127.0.0.1:30001 127.0.0.1:3002 127.0.0.1:3003 127.0.0.1:3004 127.0.0.1:3005 127.0.0.1:3006\n```\n--replicas 1 表示每个主对应一个从。\n\n# 集群更改\n## 转移插槽（slot）\n```sh\nsrc/redis-trib.rb reshard 127.0.0.1:30001\nHow many slots do you want to move (from 1 to 16384)? 1000 #转移的插槽数\nWhat is the receiving node ID? b2897dbc560a9774018559d49eb277ae75bd685b #接收的节点\nPlease enter all the source node IDs. #从指定节点转移还是从其他所有节点转移\n  Type 'all' to use all the nodes as source nodes for the hash slots.\n  Type 'done' once you entered all the source nodes IDs.\nSource node #1:all\n```\n以上插槽就搬运好了。如果要把一个节点里的所有插槽转移到另一个节点，可以简单的执行这个命令\n```sh\n./redis-trib.rb reshard --from <node-id> --to <node-id> --slots <number of slots> --yes <host>:<port>\n```\n\n## 集群扩容\n首先启动两个新的服务 30005主，30006从。\n\n将30005加入集群\n```sh\nsrc/redis-trib.rb add-node 127.0.0.1:30005 127.0.0.1:30001 #引入主节点\nsrc/redis-trib.rb add-node --slave --master-id 03ccad2ba5dd1e062464bc7590400441fafb63f2 127.0.0.1:30006 127.0.0.1:30001 #引入从节点\n```\n其中 03ccad2ba5dd1e062464bc7590400441fafb63f2 是30005的 cluster node id。然后将其他节点的插槽转移到这个节点就好了。\n\n## 集群缩减\n将主节点的插槽全部转移到别的主节点，然后执行\n```sh\nsrc/redis-trib.rb del-node 127.0.0.1:30005 03ccad2ba5dd1e062464bc7590400441fafb63f2\n```\n其中 03ccad2ba5dd1e062464bc7590400441fafb63f2 是节点 cluster node id\n\n# 集群模式的缺陷\n1. 键的批量操作支持有限，比如mset, mget，如果多个键映射在不同的槽，就不支持了\n2. 键事务支持有限，当多个key分布在不同节点时无法使用事务，同一节点是支持事务\n3. 键是数据分区的最小粒度，不能将一个很大的键值对映射到不同的节点\n4. 不支持多数据库，只有0，select 0\n5. 复制结构只支持单层结构，不支持树型结构。  \n6. **集群不能少于3个主节点，否则主从切换会失败**\n\n----------------------------\n参考资料：  \n官方教程 https://redis.io/topics/cluster-tutorial  \nredis集群高可用 https://www.cnblogs.com/leeSmall/p/8414687.html","tags":["redis"]},{"title":"Elasticsearch搭建集群","url":"/posts/1535600327/","content":"# 配置文件\n## Elasticsearch 集群中的三种角色\n\n```\n1. 此时节点可以成为任何角色\nnode.master: true #可选为主节点\nnode.data: true #可存储数据\n2. 此时节点从不选举为主节点,只用来存储数据,可作为负载器\nnode.master: false\nnode.data: true\n3. 此时节点成为主节点,且不存储任何数据,并保有空闲资源,可作为协调器\nnode.master: true\nnode.data: false\n4. 此时节点既不称为主节点,又不成为数据节点,那么可将他作为搜索器,从节点中获取数据,生成搜索结果等\nnode.master: false\nnode.data: false\n```\n\n## 本地第一台配置\n我的两个服务都在本地，所以要用端口来区分\nelasticsearch.yml\n```\ncluster.name: es-ljj\nnode.name: node-1\nhttp.port: 9200 #搜索访问的端口\ntransport.tcp.port: 9300 #节点之间通信的端口\nnode.master: true\nnode.data: true\ndiscovery.zen.ping.unicast.hosts: [\"127.0.0.1:9300\",\"127.0.0.1:9301\"] #所有节点的地址\n```\n\n## 本地第二台配置\nelasticsearch.yml\n```\ncluster.name: es-ljj\nnode.name: node-2\nhttp.port: 9201 #搜索访问的端口\ntransport.tcp.port: 9301 #节点之间通信的端口\nnode.master: true\nnode.data: true\ndiscovery.zen.ping.unicast.hosts: [\"127.0.0.1:9300\",\"127.0.0.1:9301\"] #所有节点的地址\n```\n\n## 检测是否生效\n这里两个服务都配置了node.master: true，所以先启动的会被选为 master，而后进来的，data 目录下如果已经有其他数据，则会加入失败。\n\n这时我们对两个服务进行操作\n```\n$curl -X PUT '127.0.0.1:9200/users'\n$curl -X PUT '127.0.0.1:9201/pages'\n```\n然后查看是否已经生效\n```\n$curl -X GET '127.0.0.1:9200/_cat/indices?v'\n$curl -X GET '127.0.0.1:9201/_cat/indices?v'\n```\n两台返回的都是\n```\nhealth status index uuid                   pri rep docs.count docs.deleted store.size pri.store.size\ngreen  open   users 5JUXi3KKRtyMRvWvLlwaqg   5   1          0            0      1.2kb           650b\ngreen  open   pages FyR1lz32QYyhJeC-U3_UgQ   5   1          0            0       520b           260b\n```\n表示集群已经可以使用了\n\n# 动态配置\n如果我们要在集群加入一台新服务，或者移除一个老服务，需要修改每个节点配置里的 discovery.zen.ping.unicast.hosts，然后重启每个节点。如果是希望临时修改配置配置，让新的配置马上生效，等到合适的时间再重启每个节点，可以参考 es 提供的[集群配置接口](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html)。\n\n# 集群健康\n集群健康可以通过 [head 插件](https://github.com/mobz/elasticsearch-head)来监控，也可以使用 es 提供的[集群状态接口](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state.html)。\n\n---------------------------------------\n参考资料：  \nElasticsearch5.2.1集群搭建，动态加入节点，并添加监控诊断插件 https://blog.csdn.net/gamer_gyt/article/details/59077189  \n集群配置接口 https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html","tags":["elasticsearch"]},{"title":"服务器动态扩容与php-fpm配置","url":"/posts/1534671620/","content":"对于非 sass 类的应用的容量规划，参考底部《服务器容量规划》。简单的说就是估出总量，然后根据80%的压力落在20%时间的原则，估出QPS，然后给每台机器留30%计算能力，最后得出需要的总机器数。但是对于 sass 应用，商家即使告诉你什么时候会有大活动，他们也估不出会有多少点击量。这个时候就需要另一套配置方法。这套方法是建立在云服务上的，毕竟大部分公司不但不起7x24小时维护。\n\n首先要配置出尽量多的服务器，然后关闭这些服务器。对于很多云服务商来说，这些离线的主机是不收费的。\n\n然后需要一个报警功能，当现存的服务器压力达到预警值的时候或可以自动启动上面关着的服务器，或向运维发出告警，由运维来启动。一些云服务器有告警功能，没有的话只能由本地脚本来完成。因为对外部检测服务来说服务器还是可访问的，而对日志收集器来说，出现错误日志可能已经晚了。\n\n然后就是要评估出服务行业的压力普遍集中的时间，比如出行行业是上下班，周末则要往后延。\n\n下面给一个 php-fpm 配置压力部分的说明（也是一般服务唯一需要配置的部分），详细的说明看底部官方中文文档\n\n> pm  \n> 设置进程管理器如何管理子进程。可用值：static，ondemand，dynamic。必须设置。\n> \n> static - 子进程的数量是固定的（pm.max_children）。\n> \n> ondemand - 进程在有需求时才产生（当请求时才启动。与 dynamic 相反，在服务启动时 pm.start_servers 就启动了。\n> \n> dynamic - 子进程的数量在下面配置的基础上动态设置：pm.max_children，pm.start_servers，pm.min_spare_servers，pm.max_spare_servers。\n\n**对于 pm，如果服务器没有弹性扩容方案，也不用给其他程序预留容量的话，选择\"static\"这个最合适。而\"ondemand\"最不推荐，因为等到有请求再新建进程，请求会等待较长时间。**\n\n> pm.max_children  \n> pm 设置为 static 时表示创建的子进程的数量，pm 设置为 dynamic 时表示最大可创建的子进程的数量。必须设置。\n> \n> 该选项设置可以同时提供服务的请求数限制。类似 Apache 的 mpm_prefork 中 MaxClients 的设置和 普通PHP FastCGI中的 PHP_FCGI_CHILDREN 环境变量。\n> \n> pm.start_servers  \n> 设置启动时创建的子进程数目。仅在 pm 设置为 dynamic 时使用。默认值：min_spare_servers + (max_spare_servers - min_spare_servers) / 2。\n> \n> pm.min_spare_servers  \n> 设置空闲服务进程的最低数目。仅在 pm 设置为 dynamic 时使用。必须设置。\n> \n> pm.max_spare_servers  \n> 设置空闲服务进程的最大数目。仅在 pm 设置为 dynamic 时使用。必须设置。\n> \n> pm.max_request  \n> 设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 '0' 则一直接受请求，等同于 PHP_FCGI_MAX_REQUESTS 环境变量。默认值：0。\n\n**由于php是有内存垃圾回收机制的，所以这个值是可以设的比较大，不过具体还是要看项目。**\n\n> request_terminate_timeout  \n> 设置单个请求的超时中止时间。该选项可能会对 php.ini 设置中的 'max_execution_time' 因为某些特殊原因没有中止运行的脚本有用。设置为 '0' 表示 'Off'。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。\n\n**默认不限时间是不合理的。如果一个进程花掉太长时间执行，即使程序没有出错，也会很快耗尽服务器资源。这里推荐的是 30s**\n\n---------------------------------\n参考资料：  \n服务器容量规划：https://ljj.pub/posts/1531898775/  \nphp-fpm配置说明：http://php.net/manual/zh/install.fpm.configuration.php","tags":["php"]},{"title":"一种带权重的随机选择","url":"/posts/1532591893/","content":"之前有过这样的需求，抽奖活动，奖品按一定权重随机抽取，例如：\n\n| 奖品 | a | b | c | d | e |\n|-|-|-|-|-|-|\n| 权重 | 12 | 32 | 32 | 12 | 12 |\n\n之前的做法是把每个奖品按照权重，重复加进一个数据，即：\n```\n[a,a,a,a...b,b,b,b,b...c,c,c,c,c...d,d,d,d...e,e,e...]\n```\n里面有12个a,32个b以此类推。然后用 array_rand() 选出一个。\n\n这种方法首先会的到一个很大的数组，然后循环添加奖品也很费时。今天重新思考这个问题，可以用下面的方法：\n1. 将所有权重相加得到总和\n2. 以总和为最大值得到一个随机数\n3. 循环查找随机数在数组里的\b区间，进而得到结果\n\n```php\n<?php\n$gift = ['a'=>12,'b'=>32,'c'=>32,'d'=>12,'e'=>12];\n$sum = array_sum($gift);\n$rand = mt_rand(1,$sum);\n$i=0;\n$the_gift='';\nforeach($gift as $key=>$weight){\n    $i += $weight;\n    if($rand < $i){\n        $the_gift = $key;\n        break;\n    }\n}\nvar_dump($the_gift);\n```\n虽然这个算法里也有循环，但是通常礼物\b不会很多，计算量非常小。\n\n最后给一个用 map 实现的方法，缺点是要用权重作为key，所以每个权重不能相同。\b\bhttps://www.cnblogs.com/exmyth/p/7100749.html","tags":["算法"]},{"title":"RPC的基友——事务管理器","url":"/posts/1532519316/","content":"关于事务管理器，在之前的文章[《分布式事务之mysql两阶段提交》](/posts/1529896095/)有介绍。简单的来说，就是独立于业务逻辑，专门负责执行数据库事务的服务。事务管理器对于 RPC 之重要，可以说没有事务管理器，就没有分布式 RPC。\n\n# 为什么事务管理器重要\n首先我来梳理一下没有事务管理器的情况下，RPC 服务怎么调用数据库事务。分布式数据库的情况下需要一台事务管理器管理分布式事务中每台数据库事务的状态。\n\n如果只有一台数据库。每个 RPC 都有自己的连接，所以 RPC 之间无法共享事务。这时考虑以下两种情况：\n\n1. 每个 RPC 能访问所有表\n    - rpc-1 开启了一个事务，同时调用 rpc-2，rpc-2 开启了另一个事务。如果1和2的事务访问同一个表的同一行数据，就会造成死锁。这种情况虽然可以避免，但是排查有难度。\n2. 每个 RPC 只能访问自己的表\n    - 如果每个 RPC 只能访问自己的表，那但凡 RPC 间的调用，都会变成分布式事务。这样不但代码量会变得很大，而且效率太低。不推荐这样配置。\n\n因此，**只有一台数据库的情况下，我推荐每个 RPC 都能访问所有的数据表，通过测试来避免死锁。**只有这一种情况可以不用事务管理器，其他情况都需要。\n\n# 如何实现事务管理器\n如果只有一个数据库，可以自己实现一个事务管理器，rpc-1 先从事务管理器获得事务 id，被调 rpc-2 通过事务 id，获得 rpc-1 的数据库连接。这时的事务管理器就是一个数据库连接池。这里要注意单点问题。\n\n对于分布式的情况，可以用 XA 事务，但是效率不高。可以考虑 TCC 事务，参考[《分布式事务之TCC补偿型事务》](/posts/1530843273/)。\n","tags":["架构"]},{"title":"大型服务器的架构","url":"/posts/1532314825/","content":"这里只按照我所知道的最大型架构来。\n\n|-|-|-|-|-|\n|-|-|-|-|-|\n|[DNS负载均衡](##DNS负载均衡) |\n|[负载分发](##负载分发) |\n|[网关 + web/API 服务器](##网关+web/API服务器)|\n|RPC服务器 | [服务注册](##服务注册)\n|[数据库](##数据库) | 缓存 | [消息队列](##消息队列) | 搜索引擎 | [第三方\b接口](##第三方接口)\n|[日志收集](##日志收集)|\n\n## DNS负载均衡\nDNS 负载均衡是把多个 A/CNAME 记录配置在 DNS 服务器上的一种均衡的办法。优点是不用另外配置服务器，缺点是规则生效慢，不宜多配。例如阿里巴巴华东节点就只配了4条记录。\n\n## 负载分发\n将请求分发到各台服务器的主力服务器。\b常见的负载分发服务器有 HAProxy, nginx, LVS。\n\n通过负载分发出去的请求，为了保留用户 SESSION，一种方法是对用户id hash/取模，同一个用户的请求一直导向同一台服务器。但这种方法经常造成服务器使用不均，极不推荐。推荐的做法是把 SESSION 放在缓存服务器上，请求携带 token 一路往下传。\n\n负载分发服务器虽然可以通过检测下游服务是否可用来动态更新分发规则，但本身有单点问题虽然可以用脚本和 keepalived \b灾后抢救，但仍不能保证完全高可用。不知道有什么更好的替代。\n\n## 网关+web/API服务器\nweb/API服务器是放业务逻辑代码的地方，可以在上层放一层网关，也可以把网关代码和应用代码放一起。由于 API 是对外的，尤其是有第三方使用的情况下，除了要检查数据正确性外，还要注意 API 请求本身。网关应该拦截过于频繁的请求。如果有携带 token，且 token 随时间变化的话，一样的 token 可只放行第一个。\n\n由于要经常改动，此层最合适的语言是 PHP 和 javascript(nodejs)。\n\n## 服务注册\n从 web 服务器到 RPC 服务器的请求有三种分发策略：\n1. 直接把 IP 写在配置里，优点是不用另外服务器，缺点是没有高可用可言，而且增减服务器很麻烦，适合小项目\n2. 用负载分发，优点是配置很快，有一定高可用，缺点是本身有单点问题，适合中等项目\n3. 服务注册，有以上所有优点，缺点是理论上需要5台以上服务，适合大型项目\n\n服务注册服务本身是个 kv 数据库，内部使用选举算法保证各台服务之间数据同步，挂掉几台也没有关系。RPC 服务器投入使用时先注册服务，web 服务器获取地址后按照一定规则直接向 RPC 服务器发起\b请求。web 服务器发现有网络错误时\b降低权重，之所以不直接去除是为了在服务重新可用时重新提权。市场上比较成熟的有 zookeeper, etcd, consul，前两者只是 kv 数据库，后者本身实现了注册的接口。\n\n## 数据库\n在 MySQL 正式支持集群以前，还是只能搭建主从服务器，然后用一定的算法生成 id。常见的 id 生成算法是数据库id+时间哈希，是情况还可以增加 RPC id、版本号等信息。集群会失去顺序，这个时候可以考虑同一个用户的数据只写入同一台服务器。下面贴一个蚂蚁金服的 id 生成策略：\n\n|位置|1-8|9|10|11-13|14-16|...|10-9|8-1|\n| - | - |-|-| -    | -   | - | -  | - |\n|示例|20180101|1|1|001|001|...|00|12345678|\n|说明| 8位日期 |数据版本|系统版本|系统标识码|业务标识码|自定义扩展位|用户分片位|sequence空间，可支持每天每个分表1亿笔业务，循环使用|\n\n对于超大型服务，MySQL 的主从复制速度不能满足的情况下，可以考虑 OceanBase / PhxSQL，\b他们用 paxos 算法实现了分布式情况下数据库的快速同步。\n\n## 消息队列\n队列服务器有两种用处：\n1. 把耗时多的服务放在队列里，由另一个服务异步运行\n2. 有些数据对顺序要求很高，放在队列里，把并行转为串行\n\n常见的队列服务有 kafka / RabbitMQ / RocketMQ，新版的 redis 也提供队列服务。\n\n## 第三方接口\n第三方接口由于在异地，经常会出现请求错误。这时如果时间允许的话可以睡眠若干秒后直接重试，否则放入消息队列。\n\n## 日志收集\nElastic Stack(ELK) 是现在市面上最方便的日志收集和查询的工具。日志收集除了能做产品分析外，还能给新服务上线做蓝绿测试。即先在一台权重比较低的服务器上线新版，一段时间后如果日志没有报错，再在其他服务器上新。报警服务也可以架设在日志收集服务之上。\n","tags":["架构"]},{"title":"redis数据结构备注","url":"/posts/1531967914/","content":"# Geo\nGeo 命令用来把经纬度转换成 [Geohash](https://ljj.pub/posts/1531668376/)。\n\n一般用途：\n- 获得地图上一个点附近 x米内的所有点\n\n# Hashes\n哈希表。以前会把数据序列化后作为字符串存储，现在可以直接存进 hash 里。缺点是只有一级，所以多级的情况还是要序列化。\n\n一般用途：\n- 数据库里的数据原封不动存进 hash\n\n# HyperLogLog\nHyperLogLog 的用途是输入大量的字符串，最后得到去重字符串的数量。和 Sets 的区别是速度飞快，而且空间小很多，可能只有千分之一。缺点是数据存入后会做不可逆运算，因此只能统计数量，不能再取出数据。\n\n一般用途：\n- 统计 UV\n\n# Lists\n列表。以前会用来作为消息队列，现在推荐使用 Streams。\n\n一般用途：\n- 有序的队列\n\n# Sets\n去重的无序列表。如果要维护一个去重的列表。缺点是无序。\n\n一般用途：\n- 分布式的情况下，维护一个去重表\n\n# Sorted Sets\n有序的去重列表。同样是去重的列表，可以给每个值加一个权重，得到一个顺序。\n\n一般用途：\n- 按照需要的顺序存储数据库的主键。作为数据库索引的补充。\n\n# Streams\n专门的消息队列，比 List 快很多，用来代替 Kafka, RabbitMQ 等。\n\n一般用途：\n- 消息队列\n\n# Strings\n最基本的字符串\n\n一般用途：\n- 加锁 SET key value EX 5 NX。SET 和 EX 一起操作，保证锁超时的原子性。\n- 存储序列化的数据，比如 json\n\n# Bitmap\n图是建立在 String 上的，提供直接对每一位的操作。图的操作直观上就是 offset 上的值是 0 还是 1\n\n一般用途：\n- 统计用户一年登录了哪些天 SETBIT $uid $day 1。$offset 是一年中的第几天\n- 查看用户是否在线 SETBIT KEY $uid 1。这里 $uid 只能是数字\n- 布隆过滤器。旧版可以找插件来实现\n\n---------------------------\n参考资料：  \n[HyperLogLog wiki](https://en.wikipedia.org/wiki/HyperLogLog)","tags":["redis"]},{"title":"PHP event 和 libevent 扩展的关系","url":"/posts/1531918053/","content":"PHP event 和 libevent 扩展都是对 libevent 的封装，前者有 stable 版本且一直在更新而后者只有 beta 版本。本来肯定要选 event 扩展，可是它的 pecl 页面上赫然写着依赖 libevent 扩展。陷入混乱的我给作者写了封邮件，**结论是：大胆选 event 扩展**。以下是邮件原文：\n\n> Hi,\n> \n> event extension is an alternative to libevent extension.\n> \n> You can see \"libevent\" package listed as a dependency on\n> https://pecl.php.net/package/event, but in reality \"libevent\"\n> extension is declared as **conflicting** package in package.xml:\n> \n>       <package>\n>         <name>libevent</name>\n>         <channel>pecl.php.net</channel>\n>         <min>0.0.2</min>\n>         <conflicts/>\n>         <providesextension>libevent</providesextension>\n>       </package>\n> \n> I can't recall why. But you definitely don't need libevent extension\n> in order to use \"event\".\n> \n> On Wed, 18 Jul 2018 11:28:21 +0800 (CST)\n> \"Simon Lin\" <boyquestion@163.com> wrote:\n> \n> Hi,\n> \n> I'm just confused that what is the relation between event package and\n> libevent package? The pecl page shows event package has stable\n> versions while libevent package does not. If event package depends on\n> libevent package, is event package still stable?\n> \n> \n> \n> \n> Sincerely,\n> Simon Lin\n> \n> -- \n> Ruslan Osmanov","tags":["php"]},{"title":"服务器容量规划","url":"/posts/1531898775/","content":"# 单机 QPS 评估\nQPS 是值每秒处理请求量。http 请求一般使用 apache bench 工具 ab 评估。参数说明：\n```\n格式：ab [options] [http://]hostname[:port]/path\n\n-n requests Number of requests to perform\n//本次测试发起的总请求数\n\n-c concurrency Number of multiple requests to make\n//一次产生的请求数（或并发数）\n\n-t timelimit Seconds to max. wait for responses\n//测试所进行的最大秒数，默认没有时间限制。\n\n-r Don't exit on socket receive errors.\n// 抛出异常继续执行测试任务 \n\n-p postfile File containing data to POST\n//包含了需要POST的数据的文件，文件格式如“p1=1&p2=2”.使用方法是 -p 111.txt\n\n-T content-type Content-type header for POSTing\n//POST数据所使用的Content-type头信息，如 -T “application/x-www-form-urlencoded” 。 （配合-p）\n\n-v verbosity How much troubleshooting info to print\n//设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。\n\n-C attribute Add cookie, eg. -C “c1=1234,c2=2,c3=3” (repeatable)\n//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。\n提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C ” c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8″ 。\n\n-w Print out results in HTML tables\n//以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。\n```\n\n返回：\n```sh\n$ab -n1000000 -c100 -k http://127.0.0.1:1234/\nThis is ApacheBench, Version 2.3 <$Revision: 1528965 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking 127.0.0.1 (be patient)\nCompleted 100000 requests\nCompleted 200000 requests\nCompleted 300000 requests\nCompleted 400000 requests\nCompleted 500000 requests\nCompleted 600000 requests\nCompleted 700000 requests\nCompleted 800000 requests\nCompleted 900000 requests\nCompleted 1000000 requests\nFinished 1000000 requests\n\n\nServer Software:        workerman/3.1.4\nServer Hostname:        127.0.0.1\nServer Port:            1234\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      100\nTime taken for tests:   7.240 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      73000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    138124.14 [#/sec] (mean)\nTime per request:       0.724 [ms] (mean)\nTime per request:       0.007 [ms] (mean, across all concurrent requests)\nTransfer rate:          9846.74 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.0      0       5\nProcessing:     0    1   0.2      1       9\nWaiting:        0    1   0.2      1       9\nTotal:          0    1   0.2      1       9\n\nPercentage of the requests served within a certain time (ms)\n  50%      1\n  66%      1\n  75%      1\n  80%      1\n  90%      1\n  95%      1\n  98%      1\n  99%      1\n 100%      9 (longest request)\n```\n解释：\n```\nDocument Path:测试页面\nDocument Length: 页面大小\nConcurrency Level: 测试的并发数\nTime taken for tests:整个测试持续的时间\nComplete requests:完成的请求数量\nFailed requests: 失败的请求数量\nWrite errors: 0\nTotal transferred: 整个过程中的网络传输量\nHTML transferred: 整个过程中的HTML内容传输量\nRequests per second: 最重要的指标之一，相当于LR中的每秒事务数，后面括号中的mean表示这是一个平均值\nTime per request: 最重要的指标之二，相当于LR中的平均事务响应时间，后面括号中的mean表示这是一个平均值\nTime per request: 每个连接请求实际运行时间的平均值\nTransfer rate: 平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题\n```\n**其中 Failed requests 一旦大于0就表示服务已经达到饱和，Requests per second 是估算出来的 QPS。**\n\n# 单机容量评估\n应用服务器单机的处理能力估算公式\n```\nTPC-C = ∑ (每秒钟服务处理量 * 标准的服务性能比率) / (1 - 冗余率)\n```\n比如 A 应用同时提供 serviceX 和 serviceY，在一秒内需要同时处理 serviceX 1000 笔和 serviceY 2000 笔，每个 serviceX 的标准的服务性能比率为 0.5，每个 serviceY 的标准的服务性能比率为 2，考虑 30% 的系统冗余率，那该应用服务器单机处理能力(tpmc) = ((1000 * 0.5) + (2000 * 2)) / (1 – 30%) = 6428。\n\n每个应用服务器根据自己系统提供的服务以及访问量计算出单机的处理能力。 存储服务器单机的处理能力除了考虑请求处理能力的估算外，还需要考虑硬盘的容量，主要估算的方法为每条数据库记录需要的硬盘空间，秒级需要提供的并发访问数，提供该并发能力持续的时间，估算的公式为\n```\n∑(SQL 每秒钟处理量 * SQL 记录需要的空间) * 时间\n```\n计算出在日常和活动峰值期间需要的硬盘容量，为了保障数据库空间够用，需要冗余 30% 的硬盘空间。 网络设备的容量估算主要涉及网络的 IP 资源、网络上行和下行带宽容量、网络延迟，评估的方法主要是根据业务峰值需要的网络流量进行带宽合并计算，按网络流量的上限估算网络带宽容量，IP 资源根据整体业务需要的 VM 资源数量来估算。\n\n# 集群容量评估\n首先估算峰值请求，根据2/8原则，即80%压力会集中在20%的时间里，得到一个峰值 QPS。然后根据总的容量要求计算出每个应用服务器、存储服务器需要达到的容量要求，最后根据服务器需要达到的容量除以单机的容量，得出每一个服务器需要的机器数量，按照计算出来的机器数量给对应的服务器扩容，以达到业务指标要求的容量。\n\n------------------------\n参考资料：  \n[分布式系统架构技术分析（二）](https://mp.weixin.qq.com/s/Tw6dZmj9fhjhhhN4TN8mKw)","tags":["运维"]},{"title":"用geohash来做地理距离计算","url":"/posts/1531668376/","content":"在知道 geohash 之前，对于查找附近的人这种需求，我只知道用自己的经纬度和对方的经纬度经过勾股定理来计算距离，但因为这样的方法实在是太慢没法用，最后还是用了第三方的 API 来获得结果。这片文章就来介绍一下 geohash。\n\ngeohash 是对经纬度做一系列计算，最后的到一个字符串，经纬度越精确，字符串越长，而距离越近的两点，字符串左边相同的字符就越多。例如使用 redis 的 geohash 命令得到上海人民广场地铁站的 geohash 是 wtw3sqgg0v0，上海博物馆是 wtw3sqh3ng0，老西门地铁站是 wtw3ss61250。可以看到人民广场离博物馆比较近，前6位字母是一样的，而距离较远的老西门则只有前5位一样了。这个算法可以设定精确度，越精确字符串越长。\n\n现在已经很清楚了，对于位置固定不变的东西，可以在 MySQL 保存 geo\u001chash 后用 Like 'xxx%' 来查找，缓存可以用 redis 的 \bgeoadd 和 geohash。但如果需求是一个位置实时在变的出租车，我们不是要在缓存找到出租车的 geohash，而是要根据近似的 geohash 来找到出租车的信息。可以用 redis 的 GEORADIUSBYMEMBER 命令，将数据库 id 作为 key。\n\nGeohash 具体算法实现这里就不写了，可以看维基百科(https://en.wikipedia.org/wiki/Geohash)。使用 geohash 虽然能快速的得到附近的物品，却不能得到距离。如果需要距离，可以取出经纬度后再计算。\n\n最后推荐一个 [geohash 的 PHP 扩展](https://github.com/taogogo/geohash-php-extention)\n","tags":["算法"]},{"title":"Elasticsearch基本操作","url":"/posts/1531467381/","content":"这篇文章的意义一来是给写 API 一个参考，二来是紧急情况控制台排查。因为浏览器和 postman 都不支持 GET 后面跟数据，所以所有命令都以 curl 形式给出。\n\n# 安装\n详细的安装过程就不写了，无非安装 java 后安装 elasticsearch。这里提一下，可以使用清华的镜像（https://mirrors.tuna.tsinghua.edu.cn/elasticstack/6.x/yum/6.3.1/elasticsearch-6.3.1.rpm）。如果你的开发机内存小，修改 /etc/elasticsearch/jvm.option 以下两项：\n```\n-Xms128m\n-Xmx128m\n```\n128m 是你要分配的内存。\n\n# Index\n在 Elasticsearch 里 Index 代表代表一个数据库。\n\n## 查看所有 Index：\n```sh\n$curl -X GET '127.0.0.1:9200/_cat/indices?v'\n```\n\n## 新建 Index\n```sh\n$curl -X PUT '127.0.0.1:9200/users'\n```\n返回\n```json\n{\n    \"acknowledged\": true,\n    \"shards_acknowledged\":true,\n    \"index\":\"users\"\n}\n```\n返回的数据里有 acknowledged: true 即表示操作成功。这时候查看所有 Index 可以看到 users 库。\n\n## 删除 Index\n```sh\n$curl -X DELETE '127.0.0.1:9200/users'\n```\n\n# Type\nType 类似于库(Index) 里的表，用于对 Document 分类。下面的命令查看 Index 里所有的 Type:\n```sh\n$curl '127.0.0.1:9200/_mapping?pretty'\n``` \n\n# Document\nDocument 是实际写入的数据。下面以 Index: users, Type: m 为例演示怎么操作数据。\n\n## 添加数据，修改数据\n原型：\n```\nPUT /{index}/{type}/{id}\n```\n\n例子：\n```sh\n$curl -X PUT '127.0.0.1:9200/users/m/id1' -H'Content-Type:application/json' -d '\n{\n    \"name\": \"ljj\",\n    \"age\": \"30\"\n}\n'\n```\nurl 里的“id1”是给定的 id。也可以不给，相应 method 改成 POST，返回的 _id 字段是服务给的 id。\n\n## 删除数据\n原型：\n```\nDELETE /{index}/{type}/{id}\n```\n例子：\n```sh\n$curl -X DELETE '127.0.0.0:9200/users/m/id1'\n```\n\n# 查询\n\n## 已知 id\n原型：\n```\nGET /{index}/{type}/{id}\n```\n例子：\n```sh\n$curl '127.0.0.1:9200/users/m/id1?pretty'\n```\n\n## 简易查询\n```sh\n$curl '127.0.0.1:9200/users/m/_search?q=ljj&pretty'\n$curl '127.0.0.1:9200/_search?q=name:ljj&from=1&size=1&_source=name,age'\n```\n**q 规定了字段，from 规定偏移，size 规定返回条数，_source 规定返回的字段。**\n\n可以看到，Index 和 Type 都是可以去掉的，加上则规定了范围。返回的结果里包含 Index 和 Type。\n\n## 复杂查询\n```sh\n$curl '127.0.0.1:9200/users/m/_search' -H'Content-Type:application/json' -d '\n{\n    \"query\" : {\n        \"match\": {\n            \"name\": \"ljj othername\"\n        }\n    },\n    \"from\": 1,\n    \"size\": 1\n}\n'\n```\n**query 规定了匹配规则，match 规定了字段，from 规定偏移，size 规定返回条数。**\n\nname 里面的空格表示 or 的关系。如果需要 and 则使用下面的参数:\n```json\n{\n    \"query\": {\n        \"bool\": {\n            \"must\": [\n                {\n                    \"match\": {\"name\": \"ljj\"}\n                },\n                {\n                    \"match\": {\"name\": \"othername\"}\n                }\n            ]\n        }\n    }\n}\n```\n\n# 诊断\n## 集群里文档数量\n```sh\n$curl -XGET '127.0.0.1:9200/_count?pretty' -d '\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n'\n```\n\n## 集群健康\n```sh\ncurl -XGET '127.0.0.1:9200/_cluster/health'\n```\n返回以下数据\n```json\n{\n    \"cluster_name\": \"elasticsearch\",\n    \"status\": \"green\",\n    \"timed_out\": false,\n    \"number_of_nodes\": 1,\n    ...\n}\n```\n其中 status 是我们最感兴趣的，它有一下含义\n\n颜色 | 意义\n:-|:-\ngreen | 所有主要分片和复制分片都可用\nyallow | 所有主要分片可用，但不是所有复制分片都可用\nred | 不是所有主要分片都可用\n\n\n-------------------------------\n参考资料：  \n\b[全文搜索引擎 Elasticsearch 入门教程](http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html)  \n[官方文档](https://www.elastic.co/guide/index.html)  \n《Elasticsearch 权威指南》","tags":["运维"]},{"title":"http简易指南","url":"/posts/1530930262/","content":"# HTTP 报文内容\nHTTP 报文是由一行一行的简单纯文本字符串组成的，不是二进制代码。下面是一个简单例子：\n\n请求：\n.|内容\n-|-\n起始行(start line) | GET /test/hi-there.php HTTP/1.0\n首部(header) | Accept: text/*<br>Accept-Language: en,zh\n\n响应：\n.|内容\n-|-\n起始行(start line) | HTTP/1.0 200 OK\n首部(header) | Content-type: text/plain<br>Content-length: 19\n主体(body)   | Hi! I'm a message!\n\n起始行和首部，由一个回车符（ASCII 13）和一个换行符（ASCII 10）作为结束。\n\n# 起始行\n## 常用 HTTP 方法\n请求报文起始行里的 *GET* 就是 HTTP 方法，其余方法参考下表：\n\n方法 | 描述 | 是否包含主题\n-|-|-\nGET | 从服务器获取一份文档 | 否\nHEAD | 只从服务器获取文档的首部 | 否\nPOST | 向服务器发送需要处理的数据 | 是\nPUT | 将请求的主体部分存储在服务器上 | 是\nTRACE | 对可能经过代理服务器传输到服务器上去的报文进行追踪 | 否\nOPTIONS | 决定可以在服务器上执行哪些方法 | 否\nDELETE | 从服务器上删除一份文档 | 否\n\n## HTTP 状态码\n响应报\b文起始行里的 *200* 就是 HTTP 状态吗，其他状态码参考下表：\n\n整体范围 | 已定义范围 | 分类 | 描述\n-|-|-|-\n100 ~ 199 | 100 ~ 101 | 信息提示 | 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。\n200 ~ 299 | 200 ~ 206 | 成功 | 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受\n300 ~ 399 | 300 ~ 305 | 重定向 | 这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。其中301是永久重定向，302是临时重定向。\n400 ~ 499 | 400 ~ 415 | 客户端错误 | 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。其中401是未授权，404是找不到请求资源。\n500 ~ 599 | 500 ~ 505 | 服务端错误 | 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。\n\n# 首部\nHTTP 首部字段有很多，而且\b可以添加自定义的字段，这里只列几个比较常见或重要的。\n\n首先要说明很多字段值可以加一个质量值 **\"q\"**，定义各个值的权重，例如这个首部：\n> Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0\n\nq 值的范围从 0.0 ～ 1.0（0.0是优先级最低，而1.0是优先级最高的）。注意偏好的排序不重要，只有 q 值才是重要的。\n\n## Accept\n客户端用 Accept 首部来通知服务器可以接受哪些媒体类型。\n\n- **类型**：请求首部\n- **注释**：可以用\"*\"通配符。例如\"*/*\",\"image/*\"\n- **举例**：Accept: text/*, image/*\n\n## Accept-Charset\n客户端用 Accept-Charset 通知服务器可以接受哪些字符集。\n\n- **类型**：请求首部\n- **注释**：和\b Accept 一样支持通配符\n- **举例**：Accept-Charset: utf-8\n\n## Accept-Encoding\n客户端用 Accept-Encoding 首部来告诉服务器可以接受哪些编码方式。\n\n- **类型**：请求首部\n- **举例**：Accept-Encoding: gzip;q=1.0, compress;q=0.5\n\n## Cache-Control\n\n- **类型**：通用首部\n- **举例**：Cache-Control: no-cache\n\n## Connection\n在 HTTP/1.0 中 默认关闭 Keep-Alive 模式，要通过 Connection: Keep-Alive 打开。在 HTTP/1.1 中默认开启了 Keep-alive 模式，通过加入 Connection: close 才关闭。\n\n- **类型**：通用首部\n- **举例**：Connection: close\n\n## Content-Encoding\nContent-Encoding \b首部用于说明是否对某对象进行过编码。\n\n- **类型**：实体首部\n- **举例**：Content-Encoding: compress, gzip\n\n## Content-Length\nContent-Length 首部说明实体**主体**部分的长度。HEAD 请求响应中如果有这个首部，表示如果发送的话，实体主体的长度。\n\n- **类型**：\b实体首部\n- **举例**：Content-Length: 2417\n\n## Content-Type\nContent-Type 首部说明了报文中对象的媒体类型。\n\n- **类型**：实体首部\n- **举例**：Content-Type: text/html; charset=utf-8\n\n## \bCookie, Cookie2\nCookie 用来改变 Cookie，Cookie2 是对 Cookie 的扩展\n\n- **类型**：扩展请求首部\n- **举例**：Cookie: name=\"ljj\"\n\n## Date\nDate 首部给出了报文创建的日期和时间。\n\n- **类型**：通用首部\n- **举例**：\bDate: Tue, 3 Oct 1997 02:15:31 GMT\n\n## ETag\nETag 首部为保文中包含的实体提供了实体标记。实体标记实际上就是一种标识资源的方式。\n\n- **类型**：实体首部\n- **举例**：ETag: \"11e92a-457b-31345aa\"\n\n## Location\n服务器可以通过 Location 首部将客户端导向某个资源地址。浏览器收到这个首部将会跳转。\n\n- **类型**：响应首部\n- **举例**：Location: http://www.ljj.pub\n\n## Set-Cookie, Set-Cookie2\nSet-Cookie 首部是 Cookie 的搭档，规定了 Cookie 的作用域和其他一些信息。Set-Cookie2 是对 Set-Cookie 的扩展。\n\n- **类型**：\b扩展响应首部\n- **举例**：Set-Cookie: \bname=ljj; domain=\"ljj.pub\"; path=/posts/\n\n例子里 name=ljj 是强制的，其他都是可选的\n\n## User-Agent\n客户端用 User-Agent 首部来表示其类型\n\n- **类型**：\b请求首部\n- **举例**：User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)\n\n另外\b\b说明一个，Age（秒）, Cache-Control, Expire（日期） 是设定为计算缓存生命周期的，但现在更好的做法是永久缓存，然后给 URL 加版本号的方法更新文件。\n\n# HTTP 与 WebSocket\nWebSocket 是在 HTTP 基础上的协议，需要浏览器支持。\bWebSocket \b允许客户端和服务器通过长链接双工通信，即\b两边可以不断的向另一边发送信息而不用重新连接。没有 WebSocket 协议之前如果服务器要不断向浏览器发送信息，就要打开长链接（Connection: Keep-Alive，默认打开），而且只能服务器向浏览器发送。而且由于服务端保持长链接开销很大，通常通过客户端隔一段时间请求来实现。\n\n-------------------------\n参考资料：\n《HTTP权威指南》\nhttp状态码：https://baike.baidu.com/item/HTTP状态码/5053660?fr=aladdin","tags":["http"]},{"title":"分布式事务之TCC补偿型事务","url":"/posts/1530843273/","content":"# 原理\n之前的一篇[博客](/posts/1529896095/)已经提过通过 MySQL 提供的 XA 事务来实现分布式事务。但很多人发现它性能不好，一些大公司的做法是引入 TCC 事务模型。TCC 事务模型是补偿型事务的一种实现，分为 Try/ Confirm/ Cancel 三个阶段。在解释 TCC 前，现在考虑一个现实中分布式的例子：\n\n假设你要做飞机从上海转机去北京，要求到上海和到北京都有对应时间的机票，只要有一张没有，就两张都不买了。这时候你打电话给航空公司 A，预约保留机票，再打电话给航空公司 B，如果 B 有票的话，再打给 A 确认购票，如果 B 没有票的话，也要打给 A 取消预约。\n\n这个例子里面，向两个公司确认机票对应 Try 阶段，购票对应 Confirm 阶段，取消对应 Cancel 阶段。**因此 TCC 模型就是用业务逻辑实现了数据库的事务逻辑。** 整个逻辑的一个主要方面是确认操作是否可以失败。如果保证成功，则整个操作是一个补偿操作[2]，即隐式确认，明确取消。而 Cancel 阶段就是补偿操作里的补偿部分。一个现实中的例子是，企业通过电话要求客户忽略该信件可以补偿给客户的邮寄信件。\n\nTry/ Confirm/ Cancel 三个阶段对应的数据库操作可以参考下面这个简单的例子：\n\n```sql\n# try\nINSERT RESERVATION\n\n# confirm\nUPDATE RESERVATION SET STATUS='CONFIRMED'\n\n# cancel\nUPDATE RESERVATION SET STATUS='CANCELED'\n\n```\n\n# 实现\n阿里的实现是增加一个事务管理\b器，先由主业务发起主事务，然后向每个子业务（远程服务）发起 Try 确认资源。如果资源确认通过的话，再把 Confirm 和 Cancel 的请求代码交给事务管理器，由事务管理器完成后续工作。参考下面这张图：\n![TCC实现](https://ask.qcloudimg.com/http-save/yehe-1305760/jvxyvzes5j.jpeg?imageView2/2/w/1620)\n\n# 实现难点\n1. 因为完全用业务逻辑实现，每个子事务都要提供三个接口，代码量稍大；\n2. 事务要求隔离性（Isolation），即一个事务进行的时候，其他请求读到的应该是原来的数据，这个可以用冗余数据增加版本号来解决；\n3. 如果事务管理器挂了，怎么保证事务继续执行？\n4. Confirm / Cancel 操作要实现幂等性，即事务管理器失败重启，重新执行的时候，重复上一次的操作不会出错；\n\n--------------------------\n参考资料：\n1. http://www.enterpriseintegrationpatterns.com/patterns/conversation/TryConfirmCancel.html\n2. 补偿操作：http://www.enterpriseintegrationpatterns.com/patterns/conversation/CompensatingAction.html\n3. https://cdn.ttgtmedia.com/searchWebServices/downloads/Business_Activities.pdf\n4. TCC Java 实现：https://cloud.tencent.com/developer/article/1049345","tags":["分布式"]},{"title":"git命令参考","url":"/posts/1530499706/","content":"# 查看 commit 历史\n```sh\ngit log\n```\n\n# 显示本地执行过的 git 命令\n就像 shell 的 history 一样\n```sh\ngit reflog\n```\n\n# 撤销某个 commit/reflog，并重新添加一个 commit/reflog\n```sh\ngit revert <commit-id>/<reflog-id>\n```\n只会撤销指定 commit 的改变，不影响后面的 commit。  \n如果 commit 来自另一个分支，因为添加了新的 commit，再次 merge 时，文件不会合并。\n\n# 回滚到某个 commit/reflog，并删除后面的 commit/reflog\n和revert的区别：reset命令会抹去某个commit id之后的所有commit\n```sh\ngit reset <commit-id>/<reflog-id> #默认就是-mixed参数，回滚 commit 和 add，不回滚文件\ngit reset HEAD^ #回滚到上一个 commit\ngit reset --mixed HEAD~1 #和上一个一样，HEAD~ 后跟往回退几步\ngit reset --hard <commit-id>/<reflog-id> #会滚到指定 commit，文件会改变，线上紧急回滚时用\n```\ngit reset 参数默认是 --mixed，会回滚 commit 和 add，保留文件。平时使用默认就可以了。线上运维使用 --hard 回滚代码。\n\ngit reset commit-id 和 reflog-id 的区别：  \n通常我们都是在新分支上开发，然后合并(merge)到发布分支，因此在发布分支，只要使用\n```sh\ngit reset <reflog-id>\n```\n就可以回滚 merge 操作，即开发分支上所有的 commit。非常适合线上回滚代码。\n\n这里给一个快速回滚到上一条 reflog 的代码：\n```sh\ngit reflog |awk 'NR==2{print $1}'|xargs git reset --hard\n```\n\n# 切换分支\n```sh\ngit checkout <branch-name>\n```\n放弃文件修改也可以用这个命令，但如果文件名和分支名相同的话就会搞混。所以放弃文件修改统一加上 --\n\n# 放弃文件修改\n```sh\ngit checkout -- <file-name>\ngit checkout <stash@n> -- <file-name> #从stash中拿出某个文件的修改\n```\n\n# 查看 commit/reflog 之间的文件区别\n```sh\ngit diff #查看当前修改和上一次提交的区别\ngit diff -- <file-name> #指定文件和上一次修改的区别\ngit diff <commit-id>/<reflog-id> <commit-id>/reflog-id> #查看提交/操作之间的区别\ngit diff <commit-id>/<reflog-id> -- <file-name> #指定文件提交/操作之间的区别\n```\n\n# 在当前分支基础上新建分支\n```sh\ngit checkout -b <branch-name>\n```\n\n# 拉取远程分支\n```sh\ngit checkout -b <本地分支名> origin/<远程分支名>\n```\n\n# 删除分支\n```sh\ngit branch -d <branch-name>\n```\n\n# 合并分支\n```sh\ngit merge <branch-name>\n```\n\n--------------------------\n参考资料：  \nhttp://www.bootcss.com/p/git-guide/\nhttps://github.com/521xueweihan/git-tips#回到远程仓库的状态","tags":["git"]},{"title":"tmp目录文件莫名消失及后续","url":"/posts/1530180519/","content":"有一个 WorkerMan 程序，会把 pid 放在 /tmp 目录下，过一段时间不知道为什么这个文件就消失了，然后命令行的控制就不起作用了。网上查了之后知道 linux 系统除了用户的 crontab 外，还有一些定时任务在 /etc/cron.* 系列目录下。而且有专门清除 /tmp 目录的任务，配置文件在 /usr/lib/tmpfiles.d/tmp.conf。pid 文件是不能 /tmp 下了。跟运维沟通后得知 linux 有个专门放 pid 文件的目录是 /var/run。\n\n改完程序后还不能重启进程，最好可以 reload。从运维那里得知一般程序 reload 可以用\n```sh\nkill -HUP pid\n```\n这个命令。试了以后发现不行，主程序被杀死了。看程序里面用的是 SIGUSR1 这个信号，即要执行\n```sh\nkill -USR1 pid\n```\nSIGUSR1 信号是程序自定义的信号，至于 WorkerMan 收到这个信号执行了什么，就是另一篇文章的事了。\n\n**所以这里给出结论：SIGHUP 信号的解释是挂起，大多数服务器进程都会进行复位操作并重新加载配置文件。但不适用我们自己写的程序。**","tags":["运维"]},{"title":"分布式事务之mysql两阶段提交","url":"/posts/1529896095/","content":"## 两阶段提交\n分布式事务即跨数据库事务，要求分布式系统中每个用到的服务器的事务一起提交或一起回滚。为了做到这点，一个解决方法是引入两阶段提交。\n\n两阶段提交简称 2PC，全称 Two Phase Commitment Protocol。要实现两阶段提交需要这两个管理器：\n- **资源管理器（resource manager）**：即数据库，用来管理数据，可以实现本地事务。在2PC里扮演参与者角色\n- **事务管理器（transaction manager）**：协调每个资源管理器的事务。在2PC里扮演协调者角色\n\n两阶段提交协议分为两个步骤：\n1. **准备(prepare)阶段**：即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。 \n2. **提交(commit/rollback)阶段**：当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。 \n\n## MySQL XA事务及其基本语法\nMySQL 提供了 XA 事务来支持二段式提交，但它本身不是事务管理器。XA 事务基本语法如下：\n\nXA {START|BEGIN} xid [JOIN|RESUME] 启动xid事务 (xid 必须是一个唯一值; 不支持[JOIN|RESUME]子句) \nXA END xid [SUSPEND [FOR MIGRATE]] 结束xid事务 ( 不支持[SUSPEND [FOR MIGRATE]] 子句) \nXA PREPARE xid 准备、预提交xid事务 \nXA COMMIT xid [ONE PHASE] 提交xid事务 \nXA ROLLBACK xid 回滚xid事务 \nXA RECOVER 查看处于PREPARE 阶段的所有事务\n\n## php 调用 MySQL XA 事务实现分布式事务\n首先确保 mysql 开启 XA 事务支持\n```sql\nSHOW VARIABLES LIKE '%XA%'\n```\n不是的话执行\n```sql\nSET innodb_support_xa = ON\n```\n示例代码如下：\n```php\n<?php\n$dbtest1 = new mysqli(\"172.20.101.17\",\"public\",\"public\",\"dbtest1\")or die(\"dbtest1 连接失败\");\n$dbtest2 = new mysqli(\"172.20.101.18\",\"public\",\"public\",\"dbtest2\")or die(\"dbtest2 连接失败\");\n\n//为XA事务指定一个id，xid 必须是一个唯一值。\n$xid = uniqid(\"\");\n\n//两个库指定同一个事务id，表明这两个库的操作处于同一事务中\n$dbtest1->query(\"XA START '$xid'\");//准备事务1\n$dbtest2->query(\"XA START '$xid'\");//准备事务2\n\ntry {\n    //$dbtest1\n    $return = $dbtest1->query(\"UPDATE member SET name='唐大麦' WHERE id=1\") ;\n    if($return == false) {\n       throw new Exception(\"库dbtest1@172.20.101.17执行update member操作失败！\");\n    }\n\n    //$dbtest2\n    $return = $dbtest2->query(\"UPDATE memberpoints SET point=point+10 WHERE memberid=1\") ;\n    if($return == false) {\n       throw new Exception(\"库dbtest1@172.20.101.18执行update memberpoints操作失败！\");\n    }\n\n    //阶段1：$dbtest1提交准备就绪\n    $dbtest1->query(\"XA END '$xid'\");\n    $dbtest1->query(\"XA PREPARE '$xid'\");\n    //阶段1：$dbtest2提交准备就绪\n    $dbtest2->query(\"XA END '$xid'\");\n    $dbtest2->query(\"XA PREPARE '$xid'\");\n\n    //阶段2：提交两个库\n    $dbtest1->query(\"XA COMMIT '$xid'\");\n    $dbtest2->query(\"XA COMMIT '$xid'\");\n} \ncatch (Exception $e) {\n    //阶段2：回滚\n    $dbtest1->query(\"XA ROLLBACK '$xid'\");\n    $dbtest2->query(\"XA ROLLBACK '$xid'\");\n    die($e->getMessage());\n}\n\n$dbtest1->close();\n$dbtest2->close();\n```\n\n## 两阶段提交的问题\n2PC存在同步阻塞、单点问题、脑裂等问题，此外还有数据一致性问题。如果第二阶段参与者和协调者同时挂了，挂了的这个参与者在挂之前已经执行了操作。但是由于他挂了，没有人知道他执行了什么操作。\n\n这种情况下，新的协调者被选出来之后，如果他想负起协调者的责任的话他就只能按照之前那种情况来执行commit或者roolback操作。这样新的协调者和所有没挂掉的参与者就保持了数据的一致性，我们假定他们执行了commit。但是，这个时候，那个挂掉的参与者恢复了怎么办，因为他之前已经执行完了之前的事务，如果他执行的是commit那还好，和其他的机器保持一致了，万一他执行的是roolback操作那？这不就导致数据的不一致性了么？虽然这个时候可以再通过手段让他和协调者通信，再想办法把数据搞成一致的，但是，这段时间内他的数据状态已经是不一致的了！\n\n## 三阶段提交(3PC)及其问题\n3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。在第一阶段，只是询问所有参与者是否可可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。\n\n3PC的问题在于，在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。\n\n所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。\n\n--------------------------\n参考资料：\nhttps://blog.csdn.net/soonfly/article/details/70677138\nhttps://blog.csdn.net/yyd19921214/article/details/68953629","tags":["分布式"]},{"title":"php使用epoll","url":"/posts/1529483141/","content":"之前[这篇](https://ljj.pub/posts/1528164527/)文章介绍了select, poll, epoll 的区别，已经知道 epoll 是最佳选择，也知道了 libevent 是对这三者的封装。这篇文章介绍怎么用 php 和 libevent 来实现一个 epoll 程序。\n\n首先是必要的扩展\n1. php 要支持 pcntl\n2. 系统已经装好 livevent\n3. 安装 php 扩展 event。另一个扩展 libevent 已经很久没更新了。\n\n先来实现一个纯 PHP 循环向进程发送信号的程序\n```php\n<?php\n// 给当前php进程安装一个alarm信号处理器\n// 当进程收到alarm时钟信号后会作出动作\npcntl_signal( SIGALRM, function(){\n  echo \"tick.\".PHP_EOL;\n} );\n// 定义一个时钟间隔时间，1秒钟吧\n$tick = 1;\nwhile( true ){\n  // 当过了tick时间后，向进程发送一个alarm信号\n  pcntl_alarm( $tick );\n  // 分发信号，呼唤起安装好的各种信号处理器\n  pcntl_signal_dispatch();\n  // 睡个1秒钟，继续\n  sleep( $tick );\n}\n```\n\n代码保存成 timer.php，然后 php timer.php 运行下，如果不出问题应该能跑起来。但是性能不好。下面是一个用 Event 扩展的实现：\n```php\n<?php\n// 初始化一个EventConfig\n$eventConfig = new EventConfig();\n// 根据EventConfig初始化一个EventBase\n$eventBase = new EventBase( $eventConfig );\n// 初始化一个定时器event\n$timer = new Event( $eventBase, -1, Event::TIMEOUT | Event::PERSIST, function(){\n  echo microtime( true ).\" : 起飞！\".PHP_EOL;\n} );\n// tick间隔为0.05秒钟，我们还可以改成0.5秒钟甚至0.001秒，也就是毫秒级定时器\n$tick = 0.05;\n// 将定时器event添加（可以不传 $tick）\n$timer->add( $tick );\n// eventBase进入loop状态\n$eventBase->loop();\n```\n\n这种定时器是持久的定时器（每隔X时间一定会执行一次），如果想要一次性的定时器（隔X时间后就会执行一次，执行过后再也不执行了），那么将上述代码中的“Event::TIMEOUT | Event::PERSIST”修改为“Event::TIMEOUT”即可。\n\n需要重点说明的是new Event()这行代码了，我把原型贴过来给大家看下：\n```\npublic Event::__construct ( EventBase $base , mixed $fd , int $what , callable $cb [, mixed $arg = NULL ] )\n```\n- 第一个参数是一个eventBase对象即可\n- 第二个参数是文件描述符，可以是一个监听socket、一个连接socket、一个fopen打开的文件或者stream流等。如果是时钟时间，则传入-1。如果是其他信号事件，用相应的信号常量即可，比如SIGHUP、SIGTERM等等\n- 第三个参数表示事件类型，依次是Event::READ、Event::WRITE、Event::SIGNAL、Event::TIMEOUT。**其中，加上Event::PERSIST则表示是持久发生，而不是只发生一次就再也没反应了。比如Event::READ | Event::PERSIST就表示某个文件描述第一次可读的时候发生一次，后面如果又可读就绪了那么还会继续发生一次。**\n- 第四个参数就熟悉的很了，就是事件回调了，意思就是当某个事件发生后那么应该具体做什么相应\n- 第五个参数是自定义数据，这个数据会传递给第四个参数的回调函数，回调函数中可以用这个数据。\n\n如果你有一些自定义用户数据传递给回调函数，可以利用new Event()的第五个参数，这五个参数可以给回调函数用，如下所示：\n```php\n<?php\n$timer = new Event( $eventBase, -1, Event::TIMEOUT | Event::PERSIST, function() use( &$custom ){\n  //echo microtime( true ).\" : 起飞！\".PHP_EOL;\n  print_r( $custom );\n}, $custom = array(\n  'name' => 'woshishui',\n) );\n```\n\n通过以上的案例代码可以总结一下日常流程：\n1. 创建EventConfig（非必需）\n2. 创建EventBase\n3. 创建Event\n4. 将Event挂起，也就是执行了Event对象的add方法，不执行add方法那么这个event对象就无法挂起，也就不会执行\n5. 将EventBase执行进入循环中，也就是loop方法\n\n以上就是怎么用 Event 扩展来实现一个 epoll 循环程序。可以点下面的参考资料来看验证方法，和如果用 epoll + socket 实现一个 http 服务器。\n\n--------------------------\n参考资料：\n[advanced-php](https://github.com/elarity/advanced-php/blob/master/13.%20PHP%20socket初探%20---%20硬着头皮继续libevent（二）.md)","tags":["php"]},{"title":"php进程间通信和共享内存","url":"/posts/1529460697/","content":"## 前言\n进程间通信简称 IPC，全称 InterProcess Communication。常见的进程间通信方式有：管道（分无名和有名两种）、消息队列、信号量、共享内存和socket。\n\n## 管道和FIFO\n管道是最初的 IPC 形式，我们平时使用命令 ps aux | grep php，这里的 | 就是管道。管道最大的局限是没有名字，从而只能由有亲缘关系的进程使用。这一点在 FIFO 出现后得到改进。因而 FIFO 有时也称为命名管道（named pipe）。管道一般是半双工的，但有些系统实现了全双工。\n\nphp 使用命名管道通信，创建一个管道的函数叫做posix_mkfifo()，管道创建完成后其实就是一个文件，然后就可以用任何与读写文件相关的函数对其进行操作了，代码大概演示一下：\n```php\n<?php\n// 管道文件绝对路径\n$pipe_file = __DIR__.DIRECTORY_SEPARATOR.'test.pipe';\n// 如果这个文件存在，那么使用posix_mkfifo()的时候是返回false，否则，成功返回true\nif( !file_exists( $pipe_file ) ){\n  if( !posix_mkfifo( $pipe_file, 0666 ) ){\n    exit( 'create pipe error.'.PHP_EOL );\n  }\n}\n// fork出一个子进程\n$pid = pcntl_fork();\nif( $pid < 0 ){\n  exit( 'fork error'.PHP_EOL );\n} else if( 0 == $pid ) {\n  // 在子进程中\n  // 打开命名管道，并写入一段文本\n  $file = fopen( $pipe_file, \"w\" );\n  fwrite( $file, \"helo world.\" );\n  exit;\n} else if( $pid > 0 ) {\n  // 在父进程中\n  // 打开命名管道，然后读取文本\n  $file = fopen( $pipe_file, \"r\" );\n  // 注意此处fread会被阻塞\n  $content = fread( $file, 1024 );\n  echo $content.PHP_EOL;\n  // 注意此处再次阻塞，等待回收子进程，避免僵尸进程\n  pcntl_wait( $status );\n}\n```\n运行结果如下：\n```\n$ php fifo.php\nhello world\n```\n管道的唯一限制为：\nOPEN_MAX  一个进程在任意时刻打开的最大描述符数（Posix 要求至少为16）；  \nPIPE_BUF  可原子地写往一个管道或 FIFO 的最大数据量（Posix 要求至少为512）\n\n## 消息队列\n这里的消息队列是存储于系统内核中（不是用户态）的一个链表，因而在一个进程发出消息时，不需要另外某个进程等待，这与管道相反。一般我们外部程序使用一个key来对消息队列进行读写操作。在PHP中，是通过msg_*系列函数完成消息队列操作的。\n```php\n<?php\n// 使用ftok创建一个键名，注意这个函数的第二个参数“需要一个字符的字符串”\n$key = ftok( __DIR__, 'a' );\n// 然后使用msg_get_queue创建一个消息队列\n$queue = msg_get_queue( $key, 0666 );\n// 使用msg_stat_queue函数可以查看这个消息队列的信息，而使用msg_set_queue函数则可以修改这些信息\n//var_dump( msg_stat_queue( $queue ) );  \n// fork进程\n$pid = pcntl_fork();\nif( $pid < 0 ){\n  exit( 'fork error'.PHP_EOL );\n} else if( $pid > 0 ) {\n  // 在父进程中\n  // 使用msg_receive()函数获取消息\n  msg_receive( $queue, 0, $msgtype, 1024, $message );\n  echo $message.PHP_EOL;\n  // 用完了记得清理删除消息队列\n  msg_remove_queue( $queue );\n  pcntl_wait( $status );\n} else if( 0 == $pid ) {\n  // 在子进程中\n  // 向消息队列中写入消息\n  // 使用msg_send()向消息队列中写入消息，具体可以参考文档内容\n  msg_send( $queue, 1, \"hello world\" );\n  exit;\n}\n```\n运行结果如下：\n```\n$ php msg.php\nhello world\n```\n\n## 同步与信号量\n为了同步多个进程的活动，就要允许在进程间共享数据。如果要多个进程读写同一个数据，就要引入锁。在多线程的情况下，本身有共享数据缓冲区，上锁与解锁非常简单。对于多进程上锁与解锁，可以使用信号量(semaphore)。\n\n对于多线程，php 有 pthreads 扩展，不过这个扩展需要将 php 编译成线程安全（ZTS）版本，具体参考其 [github 页面](https://github.com/krakjoe/pthreads)。这里给出一个 pthreads 互斥锁(mutex)和条件等待(cond)的演示，**但是注意，这两个类在最新版里已经删除，新版使用 synchronized 函数。这里之所以还使用旧版，是因为旧版更接近原 c 语言的用法**\n```php\n<?php\n/** 不可以使用 new 关键字，因为互斥量不是 PHP 对象 **/\n$mutex = Mutex::create();\n$cond = Cond::create();\n$condition = false;\nfunction produce()\n{\n  global $condition,$mutex,$cond;\n  Mutex::lock($mutex);\n  echo \"pth2\\n\";\n  $condition = true;\n  Cond::signal($cond);\n  // Cond::broadcast($cond);\n  Mutex::unlock($mutex);\n}\n\nfunction comsume()\n{\n  global $condition,$mutex,$cond;\n  Mutex::lock($mutex);\n  while(!$condition){\n    Cond::wait($cond, $mutex);\n  }\n  echo \"pth1\\n\";\n  Mutex::unlock($mutex);\n}\n\n// 线程2\ncomsume();\n// 线程1\nproduce();\n\n/** 永远不要忘记销毁你创建的条件变量及互斥量 **/\nCond::destroy($cond);\n/** 销毁一个处于加锁状态的互斥量的操作是无效的 **/\nMutex::unlock($mutex);\n/** 永远不要忘记销毁你创建的互斥量 **/\nMutex::destroy($mutex);\n```\n运行结果如下，pth2永远在pth1前，即两个线程通过 mutex 和 cond 的结合使其线程间同步\n```\npth2\npth1\n```\n\n题外话：如果没有 mutex，signal 可能在 wait 之前执行，这样 wait 永远等不到 signal。mutex 和 cond 都是锁死等待，之所以需要 cond 是因为 Cond::wait() 后线程会释放锁，进入休眠，不再循环判断条件。在Cond::wait() 释放 mutex 之前，线程依靠 while() 保证程序不会执行到 echo。\n\n对于信号量，php 提供 sem_acquire(), sem_get(), sem_release(), sem_remove() 4个函数。因为信号量一般和共享内存一起使用，所以代码在下一节共享内存中演示。\n\n## 共享内存\n共享内存是最快是进程间通信方式，因为n个进程之间并不需要数据复制，而是直接操控同一份数据。实际上信号量和共享内存是分不开的，要用也是搭配着用。*NIX的一些书籍中甚至不建议新手轻易使用这种进程间通信的方式，因为这是一种极易产生死锁的解决方案。共享内存顾名思义，就是一坨内存中的区域，可以让多个进程进行读写。这里最大的问题就在于数据同步的问题，比如一个在更改数据的时候，另一个进程不可以读，不然就会产生问题。所以为了解决这个问题才引入了信号量，信号量是一个计数器，是配合共享内存使用的，一般情况下流程如下：\n- 当前进程获取将使用的共享内存的信号量\n- 如果信号量大于0，那么就表示这块儿共享资源可以使用，然后进程将信号量减1\n- 如果信号量为0，则进程进入休眠状态一直到信号量大于0，进程唤醒开始从1\n\n一个进程不再使用当前共享资源情况下，就会将信号量减1。这个地方，信号量的检测并且减1是原子性的，也就说两个操作必须一起成功，这是由系统内核来实现的。\n\n```php\n<?php\n// sem key\n$sem_key = ftok( __FILE__, 'b' );\n$sem_id = sem_get( $sem_key );\n// shm key\n$shm_key = ftok( __FILE__, 'm' );\n$shm_id = shm_attach( $shm_key, 1024, 0666 );\nconst SHM_VAR = 1;\n$child_pid = [];\n// fork 2 child process\nfor( $i = 1; $i <= 2; $i++ ){\n  $pid = pcntl_fork();\n  if( $pid < 0 ){\n    exit();\n  } else if( 0 == $pid ) {\n\t// 获取锁\n\tsem_acquire( $sem_id );\n\tif( shm_has_var( $shm_id, SHM_VAR ) ){\n\t  $counter = shm_get_var( $shm_id, SHM_VAR );\n\t  $counter += 1;\n\t  shm_put_var( $shm_id, SHM_VAR, $counter );\n\t} else {\n\t  $counter = 1;\n\t  shm_put_var( $shm_id, SHM_VAR, $counter );\n\t}\n\t// 释放锁，一定要记得释放，不然就一直会被阻锁死\n  sem_release( $sem_id );\n  // 释放后删除\n  sem_remove( $sem_id );\n\texit;\n  } else if( $pid > 0 ) {\n    $child_pid[] = $pid;\n  }\n}\nwhile( !empty( $child_pid ) ){\n  foreach( $child_pid as $pid_key => $pid_item ){\n    pcntl_waitpid( $pid_item, $status, WNOHANG );\n\tunset( $child_pid[ $pid_key ] );\n  }\n}\n// 休眠2秒钟，2个子进程都执行完毕了\nsleep( 2 );\necho '最终结果'.shm_get_var( $shm_id, SHM_VAR ).PHP_EOL;\n// 记得删除共享内存数据，删除共享内存是有顺序的，先remove后detach，顺序反过来php可能会报错\nshm_remove( $shm_id );\nshm_detach( $shm_id );\n```\n运行结果如下：\n```\n$ php shm.php\n最终结果2\n```\n\n确切说，如果不用sem的话，上述的运行结果在一定概率下就会产生1而不是2。但是只要加入sem，那就一定保证100%是2，绝对不会出现其他数值。\n\n## php 守护进程和 socket 通信\n进程间通信的前提是 php 需要是守护进程，不然还没收到信息就退出了。php 守护进程需要用到 pcntl_fork() 生成子进程。socket 通信需要用到 socket_ 系列函数。这两个参考资料中的 advanced-php 已经有详细介绍，这篇文章就不写了。也可以看官方文档了解。\n\n--------------------------\n参考资料：\n《unix网络编程：第二卷》\n[advanced-php](https://github.com/elarity/advanced-php)\n[PCNTL函数](http://php.net/manual/zh/book.pcntl.php)\n[Sockets函数](http://php.net/manual/zh/book.sockets.php)\n[posix函数](http://php.net/manual/zh/ref.posix.php)\n[Semaphore函数](http://php.net/manual/zh/book.sem.php)","tags":["php"]},{"title":"mysql运维","url":"/posts/1529389113/","content":"### SHOW STATUS\nshow status 命令会显示每个服务器变量和值，可以执行以下命令单个查看：\n```\nshow status where Variable_name like 'Conne%'\n```\n以下是一下重要的：\n\n#### 线程和连接统计\n- Connections, Max_used_connections, Threads_connected\n- Aborted_clients, Aborted_connects\n- Bytes_received, Bytes_sent\n- Slow_lanuch_threads, Threads_cached, Threads_created,\nThreads_running\n\n如果Aborted_connects不为0，可能意味着网络有问题或某人尝试连接但失败（可能用户指定了错误的密码或无效的数据库，或某个监控系统正在打开TCP的3306端口来检测服务器是否活着）。如果这个值太高，可能有严重的副作用：导致MySQL阻塞一个主机。\n\n#### 二进制日志状态\nBinlog_cache_use和Binlog_cache_disk_use状态变量显示了在二进制日志缓存中有多少事务被存储过，以及多少事务因超过二进制日志缓存而必须存储到一个临时文件中。\n\n#### SELECT类型\nSelect_*\b 变量是特定类型 SELECT 查询的计数器。其中Select_scan表示全表扫描，Select_range_check 和 Select_full_join 表示\b无索引的联接。这三个开销较大。\n\n#### 表锁\nTable_locks_immediate和Table_locks_waited变量可告诉你有多少锁被立即授权，有多少锁需要等待。但请注意，它们只是展示了服务器级别锁的统计，并不是存储引擎级的锁统计。\n\n### SHOW ENGINE INNODB STATUS\n显示 InnoDB 引擎的信息，只有一列。因为不是专业运维，这里只介绍几个需要了解的段。\n\n#### LATEST DETECTED DEADLOCK\n只有当前服务器内有死锁时才会出现，内容是死锁的上下文\n\n### SHOW PROCESSLIST\n进程列表是当前连接到MySQL的连接或线程的清单。**这个命令可以看哪些线程持有锁**\n\n--------------------------\n参考资料：《高性能MySQL》","tags":["mysql"]},{"title":"mysql explain 中各列的意义","url":"/posts/1529374970/","content":"\n## select_type 列\n这一列显示是哪种类型的 SELECT。最外层是 PRIMARY，其他部分标记如下：\n- SUBQUERY  \n  包含在SELECT列表中的子查询中的SELECT（换句话说，不在FROM子句中）\n- DERIVED  \n  包含在 FROM 子句的子查询中的SELECT。MySQL 会产生一个临时表。\n- UNION  \n  在 UNION 中的第二个和随后的 SELECT。\n- UNION RESULT  \n  用来从UNION的匿名临时表检索结果的SELECT被标记为UNION RESULT\n\n## table 列\n这一列显示了对应行正在访问哪个表。\n\n当在FROM子句中有子查询时，table列是<derivedN>的形式，其中N是子查询的id。这总是“向前引用”——换言之，N指向EXPLAIN输出中后面的一行。\n\n当有UNION时，UNION RESULT的table列包含一个参与UNION的id列表。这总是“向后引用”，因为UNION RESULT出现在UNION中所有参与行之后。\n\n## type 列\n访问类型，就是 MySQL 决定如何查找表中的行。下面一次从最差到最优：\n- ALL  \n  全表扫描\n- index  \n  索引扫描，也要扫描全表，只是按照索引次序进行而不是行，避免了排序。\n- range  \n  范围查询是一个有限制的索引扫描。WHERE 里带 BETWEEN 或 > <的查询。\n- ref  \n  索引访问。叫 ref 是因为索引要跟某个参考值比较。ref_or_null 是 ref 的一个变体，它意味着 MySQL 必须进行第二次查找以找出 NULL 条目。\n- eq_ref  \n  使用主键或唯一索引\n- const, system  \n  MySQL 对语句优化后，变量被转为常量\n- NULL  \n  只通过索引，不用访问数据表\n\n## possible_keys 列\n这一列显示了查询可以使用哪些索引，不一定真的用到。\n\n## key 列\n这一列显示了 MySQL 决定采用那个索引。\n\n## key_len 列\n该列显示了索引的字节数，不是表中数据的字节数。\n\n## ref 列\n这一列显示了之前的表在key列记录的索引中查找值所用的列或常量。\n\n## rows 列\n这一列是 MySQL 估计为了找到目标要读取的行数。不是最终目标行数。\n\n## filtered 列\nrows 占总行数的比例\n\n## Extra 列\n- Using index  \n  表示 MySQL 使用覆盖索引，不需要访问数据表\n- Using where  \n  WHERE 条件使用了索引\n- Using temporary  \n  使用了临时表\n- Using filesort  \n  使用了外部索引排序\n- Range checked for each record (index map: N)  \n  没有好用的索引\n\n\n--------------------------\n参考资料：《高性能MySQL》","tags":["mysql"]},{"title":"用python做爬虫的正确姿势","url":"/posts/1529320519/","content":"已经用 python 做了不知道多少爬虫了，看看网上关于这个题材的文章都已经很老了，这篇文章介绍下我的做法。\n\n一个爬虫程序至少需要抓取和解析两个部分，抓取我使用的是 [requests](https://github.com/requests/requests)。这个库除了封装 get, post 请求外，尤其方便的是封装了会话( session )，自动更新 cookies。对抓取需要登录的网站特别好用。\n\n解析我使用的是 [pyquery](https://github.com/gawel/pyquery)。这个库对 jQuery 达到了很高的模仿，熟悉 jQuery 的人上手非常快。通常我都是在浏览器的 console 里复制 html 元素的 css 选择器或者 xpath 路径。这里要注意浏览器会给选择器添加元素，例如 tbody，复制出来是 table > tbody > tr。但其实 html 里没有 tbody 这个元素。手动去掉就好了。\n\n----------------------\n此外 python 还有一个重量级的爬虫库叫 scrapy。这个以前会用，现在已经很少用了。如果是大工程可以考虑。","tags":["python"]},{"title":"golang开发环境搭建","url":"/posts/1529303379/","content":"### 安装\nMac 下安装 Go 编译器只要执行\n```sh\nbrew install go\n```\n就可以了。各 linux 也可以使用自己的包管理器直接安装\n\n### 工作空间\n首先找一个地方放我们的工作空间，比如我选的是$HOME/Documents/gowork。这个目录的位置不能是 Go 安装目录。\n```sh\n$ mkdir $HOME/Documents/gowork\n```\nGo代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录：\n- src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包），\n- pkg 目录包含包对象，\n- bin 目录包含可执行命令。\n\n下面是一个例子：\n```\nbin/\n    hello       # 编译好的二进制文件，可执行命令\npkg/\n    darwin_amd64/\n        github.com/questionlin/\n            stringutil.a      # 编译好的包对象\nsrc/\n    github.com/questionilin/\n        hello/\n            hello.go        # 源代码\n            hello_test.go   # 测试文件源代码\n        stringutil/\n            reverse.go      # 包源码\n\n```\n\n### \bGOPATH 环境变量\n执行下面的命令\n```sh\n$ export GOPATH=$HOME/gowork\n$ export PATH=$PATH:$GOPATH/bin\n```\n\n### 第一个程序\n我在 github 的用户名是 questionlin，我要做的第一个程序叫 hello。执行命令\n```sh\n$ mkdir -p $GOPATH/src/github.com/questionlin/hello\n$ cd $GOPATH/src/github.com/questionlin/hello\n$ touch hello.go\n```\n写入一下代码\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Printf(\"Hello, world.\\n\")\n}\n```\n执行一下命令编译。这个命令在任何目录都可以执行，不需要在工作空间\n```sh\n$ go install github.com/questionlin/hello\n```\n如果在工作空间可以省略路径\n```sh\n$ cd $GOPATH/src/github.com/questionlin/hello\n$ go install\n```\n现在执行看看\n```sh\n$ $GOPATH/bin/hello\nHello, world.\n```\n\n### 第一个库\n首先创建目录：\n```sh\n$ mkdir $GOPATH/src/github.com/questionlin/stringutil\n$ cd $GOPATH/src/github.com/questionlin/stringutil\n$ touch reverse.go\n```\n写入一下内容\n```go\n// stringutil 包含有用于处理字符串的工具函数。\npackage stringutil\n\n// Reverse 将其实参字符串以符文为单位左右反转。\nfunc Reverse(s string) string {\n\tr := []rune(s)\n\tfor i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n\t\tr[i], r[j] = r[j], r[i]\n\t}\n\treturn string(r)\n}\n```\n使用 go build 来编译:\n```sh\n$ go build github.com/questionlin/stringutil\n```\n如果你在该包的源码目录中，只需执行：\n```sh\n$ go build\n```\n修改原来的 hello.go 文件，加入这个包：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/questionlin/stringutil\"\n)\n\nfunc main() {\n\tfmt.Printf(stringutil.Reverse(\"!oG ,olleH\"))\n}\n```\n然后在编译一次 hello：\n```sh\n$ go install github.com/questionlin/hello\n```\n现在再运行一次\n```sh\n$ hello\nHello, Go!\n```\n完成以上步骤后，你的工作区间应该是像最上面介绍工作空间那章里一样\n\n\n### 包名\nGo源文件中的第一个语句必须是\n```go\npackage 名称\n```\n这里的 名称 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 名称。）\n\nGo的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。\n\n可执行命令必须使用 package main。\n\n### 测试\nGo拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。\n\n你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。\n\n我们可通过创建文件 $GOPATH/src/github.com/questionlin/stringutil/reverse_test.go 来为 stringutil 添加测试，其内容如下：\n```go\npackage stringutil\n\nimport \"testing\"\n\nfunc TestReverse(t *testing.T) {\n\tcases := []struct {\n\t\tin, want string\n\t}{\n\t\t{\"Hello, world\", \"dlrow ,olleH\"},\n\t\t{\"Hello, 世界\", \"界世 ,olleH\"},\n\t\t{\"\", \"\"},\n\t}\n\tfor _, c := range cases {\n\t\tgot := Reverse(c.in)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Reverse(%q) == %q, want %q\", c.in, got, c.want)\n\t\t}\n\t}\n}\n```\n接着使用 go test 运行该测试：\n```sh\n$ go test github.com/questionlin/stringutil\nok  \tgithub.com/questionlin/stringutil 0.165s\n```\n\n\n最后给一个墙内能用的 golang 学习教程：\nhttps://tour.go-zh.org/list\n\n参考：https://go-zh.org/doc/\n","tags":["golang"]},{"title":"linux硬盘满了怎么清理","url":"/posts/1528685621/","content":"1. 使用 df -h 查看硬盘剩余空间\n2. 使用 du --max-depth=1 -h 一级一级查看硬盘文件占用，找到适合删掉的文件\n3. 如果是只想删掉大文件，可以使用 find . -maxdepth 1 -size +100M\n```sh\n#df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1        30G   12G   17G  40% /\ndevtmpfs        7.8G     0  7.8G   0% /dev\n/dev/vdb         99G   55G   39G  59% /opt\n\n\n#du --max-depth=1 -h\n272K ./.gconf \n32K ./.mcop \n16K ./.redhat \n1.7M ./.thumbnails \n8.0K ./.gconfd \n7.5M . \n\n#find . -maxdepth 1 -size +100M\n./.gconf \n./.mcop \n./.redhat \n./.thumbnails \n./.gconfd \n```","tags":["运维"]},{"title":"MySQL索引结构和优化","url":"/posts/1528513470/","content":"## B-Tree 索引\nInnoDB 使用的是B+Tree，即每一个叶子结点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。B-Tree通常意味着所有的值都是按**顺序**存储在叶子节点的，并且每一个叶子页到根的距离相同。\n\n假设有如下数据表：\n```sql\nCREATE TABLE People (\n    last_name varchar(50)    not null,\n    first_name varchar(50)   not null,\n    dob date                 not null,\n    gender enum('m', 'f')  not null,\n    key(last_name, first_name, dob)\n);\n```\n可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。**其中键前缀查找只适用于根据最左前缀的查找**。此索引对如下类型的查询有效。\n\n- 全值匹配  \n  全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找 last_name 为 Allen, first_name 为 Cuba 、出生于1960-01-01的人。\n- 匹配最左前缀  \n  索引可用于查找所有 lat_name 为Allen的人，即只使用索引的第一列。\n- 匹配列前缀  \n也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。\n- 匹配范围值  \n例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。\n- 精确匹配某一列并范围匹配另外一列  \n前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头（比如Kim、Karl等）的人。即第一列last_name全匹配，第二列frst_name范围匹配。\n\n### B-Tree索引的限制：\n- 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。\n- 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列。\n- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询WHERE last_name='Smith' AND frst_name LIKE 'J％' AND dob='1976-12-23'，这个查询只能使用索引的前两列，因为这里LIKE是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。在本章的索引案例学习部分，我们将演示一个详细的案例。\n\n到这里读者应该可以明白，前面提到的索引列的顺序是多么的重要：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。\n\n## 高性能索引策略\n### 独立的列\n**索引列不能是表达式的一部分，也不能是函数的参数。** 以下是失败例子：\n```\nmysql> SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\nmysql> SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;\n```\n\n### 前缀索引和索引选择性\n有时候需要索引很长的字符列，这会让索引变得大且慢。\b诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长。  \n现在我们有如下数据集\n```\nmysql>SELECT COUNT(*) AS cnt, city FROM city GROUP BY city ORDER BY cnt DESC LIMIT 10;\n-------------------------------------\n| cnt | city|\n+-----+-----+\n| 65 | London |\n| 49 | Hiroshima |\n| 48 | Teboksary |\n| 48 | Pak Kret |\n| 48 | Yaound |\n| 47 | Tel Aviv-Jaffa |\n| 47 | Shimoga |\n| 45 | Cabuyao |\n| 45 | Callao |\n| 45 | Bislig |\n```\n注意到，上面每个值都出现了45～65次。现在查找到最频繁出现的城市前缀，先从3个前缀字母开始：\n```\nmysql>SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref FROM city GROUP BY pref ORDER BY cnt DESC LIMIT 10;\n| cnt | pref |\n+-----+------+\n| 483 | San |\n| 195 | Cha |\n| 177 | Tan |\n| 167 | Sou |\n| 163 | al- |\n| 163 | Sal |\n| 146 | Shi |\n| 136 | Hal |\n| 130 | Val |\n| 129 | Bat |\n```\n每个前缀都比原来的城市出现的次数更多，因此唯一前缀比唯一城市要少得多。然后我们增加前缀长度，直到这个前缀的选择性接近完整列的选择性。经过实验后发现前缀长度为7时比较合适：\n```\nmysql>SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref FROM city GROUP BY pref ORDER BY cnt DESC LIMIT 10;\n| cnt | pref |\n+-----+------+\n| 70 | Santiag |\n| 68 | San Fel |\n| 65 | London |\n| 61 | Valle d |\n| 49 | Hiroshi |\n| 48 | Teboksa |\n| 48 | Pak Kre |\n| 48 | Yaound |\n| 47 | Tel Avi |\n| 47 | Shimoga |\n```\n计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：\n```\nmysql> SELECT COUNT(DISTINCT LEFT(city, 7))/COUNT(*) FROM city;\n| COUNT(DISTINCT city)/COUNT(*) |\n+-------------------------------+\n| 0.0310 |\n```\n通常来说（尽管也有例外情况），这个例子中如果前缀的选择性能够接近0.031，基本上就可用了。\n\n在上面的示例中，已经找到了合适的前缀长度，下面演示一下如何创建前缀索引：\n```\nmysql> ALTER TABLE sakila.city_demo ADD KEY (city(7));\n```\n前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。\n\n\n--------------------------\n参考资料：《高性能MySQL》","tags":["mysql"]},{"title":"JVM 垃圾处理的一些总结","url":"/posts/1528196487/","content":"## 内存管理\n### 程序计数器\n程序计数器（Program Counter Register），用来记录程序已经执行到的行号，当虚拟机在多个线程轮流切换时，靠它回到正确的执行位置。\n\n### 堆和栈\nJava 内存可以大致分为：分为虚拟机栈，本地方法栈，Java 堆，方法区，运行时常量池，直接内存。各自用来存储虚拟机和用户程序的代码、变量和其他一些信息。其中，Java 堆是所有线程共享的一块内存区域，唯一目的时存放对象实例。因此也成为垃圾管理的主要区域。\n\n## 垃圾收集\n### 判断对象是否需要被清理\n判断对象是否需要被清理可以分为引用计数算法和可达性分析算法。\n\n引用计数算法的原理是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当饮用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n\n可达性分析算法通过树来保存对象的引用链，如果对象和根（GC Roots）不再有引用链时，就被判断判断为不可达。此时对象不会被立即回收，而是要经历一个 finalize() 方法的回收过程，在此过程中对象可以自救。\n\n\n### 垃圾收集算法\n#### 标记-清除算法\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n#### 复制算法\n为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。\n\n#### 标记-整理算法\n复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。\n\n根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n#### 分代收集算法\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。\n\n--------------------------\n参考资料：《深入理解Java虚拟机：JVM高级特性与最佳实践》","tags":["java"]},{"title":"通过例子理解mysql事务的4种隔离级别","url":"/posts/1528164495/","content":"SQL标准定义了4种隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。\n\n低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。\n\n首先，我们使用 test 数据库，新建 tx 表。\n\n### 第1级别：Read Uncommitted(读取未提交内容)\n(1)所有事务都可以看到其他未提交事务的执行结果  \n(2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少  \n(3)该级别引发的问题是——脏读(**Dirty Read**)：读取到了未提交的数据\n```sh\n#首先，修改隔离级别\nset tx_isolation='READ-UNCOMMITTED';\nselect @@tx_isolation;\n+------------------+\n| @@tx_isolation   |\n+------------------+\n| READ-UNCOMMITTED |\n+------------------+\n\n#事务A：启动一个事务\nstart transaction;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：也启动一个事务(那么两个事务交叉了)在事务B中执行更新语句，且不提交\nstart transaction;\nupdate tx set num=10 where id=1;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：那么这时候事务A能看到这个更新了的数据吗?\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |   --->可以看到！说明我们读到了事务B还没有提交的数据\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：事务B回滚,仍然未提交\nrollback;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：在事务A里面看到的也是B没有提交的数据\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |      --->脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n```\n-------------------------------------\n### 第2级别：Read Committed(读取提交内容)\n(1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）  \n(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变  \n(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。  \n|——>导致这种情况的原因可能有：\n1. 有一个交叉的事务有新的commit，导致了数据的改变  \n2. 一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit\n```sh\n#首先修改隔离级别\nset tx_isolation='read-committed';\nselect @@tx_isolation;\n+----------------+\n| @@tx_isolation |\n+----------------+\n| READ-COMMITTED |\n+----------------+\n\n#事务A：启动一个事务\nstart transaction;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：也启动一个事务(那么两个事务交叉了)在这事务中更新数据，且未提交\nstart transaction;\nupdate tx set num=10 where id=1;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：这个时候我们在事务A中能看到数据的变化吗?\nselect * from tx; --------------->\n+------+------+                |\n| id   | num  |                |\n+------+------+                |\n|    1 |    1 |--->并不能看到！  |\n|    2 |    2 |                |\n|    3 |    3 |                |\n+------+------+                |——>相同的select语句，结果却不一样\n                               |\n#事务B：如果提交了事务B呢?         |\ncommit;                        |\n                               |\n#事务A:                         |\nselect * from tx; --------------->\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |--->因为事务B已经提交了，所以在A中我们看到了数据变化\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n```\n-------------------------------------\n### 第3级别：Repeatable Read(可重读)\n(1)这是MySQL的默认事务隔离级别  \n(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行  \n(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行  \n(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题\n```sh\n#首先，更改隔离级别\nset tx_isolation='repeatable-read';\nselect @@tx_isolation;\n+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+\n\n#事务A：启动一个事务\nstart transaction;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：开启一个新事务(那么这两个事务交叉了)在事务B中更新数据，并提交\nstart transaction;\nupdate tx set num=10 where id=1;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\ncommit;\n\n#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 | --->还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：只有当事务A也提交了，它才能够看到数据变化\ncommit;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n```\n-------------------------------------\n### 第4级别：Serializable(可串行化)\n(1)这是最高的隔离级别  \n(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。  \n(3)在这个级别，可能导致大量的超时现象和锁竞争\n```sh\n#首先修改隔离界别\nset tx_isolation='serializable';\nselect @@tx_isolation;\n+----------------+\n| @@tx_isolation |\n+----------------+\n| SERIALIZABLE   |\n+----------------+\n\n#事务A：开启一个新事务\nstart transaction;\n\n#事务B：在A没有commit之前，这个交叉事务是不能更改数据的\nstart transaction;\ninsert tx values('4','4');\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\nupdate tx set num=10 where id=1;\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n```\n-------------------------------------\n| 隔离级别                      | 脏读 | 不可重复读 | 幻读 |\n| - | :-: | :-: | :-: |\n| 读未提交 ( Read uncommitted ) | ✓ | ✓ | ✓ |\n| 读已提交 ( Read committed )   | × | ✓ | ✓ |\n| 可重复读 ( Repeatable read )  | × | × | ✓ |\n| 可串行化 ( Serializable )     | × | × | × |\n\n参考文章\nhttp://xm-king.iteye.com/blog/770721\n\n转自：http://www.cnblogs.com/snsdzjlz320/p/5761387.html","tags":["mysql"]},{"title":"线上代码和rpc debug哪家强","url":"/posts/1528164505/","content":"标题两种情况，除了看日志外，还有一种做法是做一种转发器，把断点输出转发到程序员这边。这篇文章安利下我做的转发器 [rebugger](https://github.com/questionlin/rebugger)。\n\nrebugger 的原理是用 WorkerMan 做一个中转站，服务器通过 http 请求向中发出消息，中转站提取出内容，转发到程序员这边的 telnet \b客户端。例如 PHP 服务器，程序只要执行 file_get_contents() 就能把消息发出去了。\n\n使用 rebugger \b的优点是 file_get_contents() 一个函数就把消息发出去了，轻便无依赖。缺点是 get 请求不能有特殊字符，特殊情况需要转义一下。更重的做法是做一个插件，程序引入后可以有一个接口，直接发送 socket 请求给telnet 客户端。不过 rebugger 应该已经能满足大部分 php 程序员的需求了。","tags":["安利"]},{"title":"select poll epoll 之间的区别","url":"/posts/1528164527/","content":"select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。\n\n今天对这三种IO多路复用进行对比，参考网上和书上面的资料，整理如下：\n\n### 1. select 实现\nselect 的调用过程如下所示：  \n![过程图](http://wx4.sinaimg.cn/large/726f09bbgy1frycff5ubgj20hk0a8q34.jpg)\n1. 使用 copy_from_user 从用户控件拷贝 fd_set 到内核空间\n2. 注册回调函数 __pollwait\n3. 遍历所有 fd，调用其对应的 poll 方法（对于 socket， 这个 poll 方法是 sock_poll， sock_poll \b根据情况会调用到 tcp_poll, udp_poll 或者 datagram_poll)\n4. 以 tcp_poll 为例，其核心时间就是 __pollwait，也就是上面注册的回调函数。\n5. __pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk->sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。\n6. poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。\n7. 如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。\n8. 把fd_set从内核空间拷贝到用户空间。\n\n### 总结\nselect的几大缺点：\n\n（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大\n\n（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大\n\n（3）select支持的文件描述符数量太小了，默认是1024\n\n（4）你不能在等待的时候修改描述符集\n\n### 2. poll 实现\npoll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，没有大小限制，其他的都差不多。\n\n关于select和poll的实现分析，可以参考下面几篇博文：\n\nhttp://blog.csdn.net/lizhiguo0532/article/details/6568964#comments\n\nhttp://blog.csdn.net/lizhiguo0532/article/details/6568968\n\nhttp://blog.csdn.net/lizhiguo0532/article/details/6568969\n\nhttp://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-\n\nhttp://linux.chinaunix.net/techdoc/net/2009/05/03/1109887.shtml\n\n### 3. epoll\nepoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。\n\n对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。\n\n对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。\n\n对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。\n\n### 总结：\n\n（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。\n\n（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。\n\n（3）即使一个线程处在 epoll_wait \b函数中，你也可以随时修改列表。\b\n\n（4）可以通过 epoll_wait() 使多个线程在同一个 epoll 队列中等待，这是 select / poll 无法做到的。\n\n### libevent\nlibevent 是一个库，将以上的方法封装在一套 API 中，使得\b同一套代码可以在不同系统中使用（\bFreeBSD 使用 kqueue)。\n\n参考资料：\n**https://www.cnblogs.com/Anker/p/3265058.html**\n\n**https://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/**\n\nhttp://www.cnblogs.com/apprentice89/archive/2013/05/09/3070051.html\n\nhttp://www.linuxidc.com/Linux/2012-05/59873p3.htm\n\nhttp://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\n\nhttp://blog.csdn.net/kkxgx/article/details/7717125\n\nhttps://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/epoll-example.c\n\n三种方式的用法：\n\nselect: http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html\n\npoll: http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html\n\nepoll: http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html\n"},{"title":"mysql配置主从分离","url":"/posts/1528164516/","content":"原理：主服务器（Master）负责网站NonQuery操作，从服务器负责Query操作，用户可以根据网站功能模特性块固定访问Slave服务器，或者自己写个池或队列，自由为请求分配从服务器连接。主从服务器利用MySQL的二进制日志文件，实现数据同步。二进制日志由主服务器产生，从服务器响应获取同步数据库。\n\n具体实现：\n1. 配置 Master 主服务器\n    1. 在 Master MySQL 上创建用户'repl'，并允许其他 Slave 服务可以通过远程访问 Master，通过该用户读取二进制日志，\b实现数据同步。\n\n    ```\n    1 mysql>create user repl; //创建新用户\n    2 //repl用户必须具有REPLICATION SLAVE权限，除此之外没有必要添加不必要的权限，密码为mysql。说明一下192.168.0.%，这个配置是指明repl用户所在服务器，这里%是通配符，表示192.168.0.0-192.168.0.255的Server都可以以repl用户登陆主服务器。当然你也可以指定固定Ip。\n    3 mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.0.%' IDENTIFIED BY 'mysql';\n    ```\n\n    2. 找到MySQL安装文件夹修改my.Ini文件。mysql中有好几种日志方式，这不是今天的重点。我们只要启动二进制日志log-bin就ok。\n    在[mysqld]下面增加下面几行代码\n\n    ```\n    1 server-id=1   //给数据库服务的唯一标识，一般为大家设置服务器Ip的末尾号\n    2 log-bin=master-bin\n    3 log-bin-index=master-bin.index\n    ```\n\n    3. 查看日志\n    ```\n    mysql> SHOW MASTER STATUS;\n    +-------------------+----------+--------------+------------------+\n    | File | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n    +-------------------+----------+--------------+------------------+\n    | master-bin.000001 | 1285 | | |\n    +-------------------+----------+--------------+------------------+\n    1 row in set (0.00 sec)\n    ```\n    重启 MySQL 服务\n\n2. \b配置 Slave 从服务器 (windows)\n    1. 找到MySQL安装文件夹修改my.ini文件，在[mysqld]下面增加下面几行代码\n    ```\n    1 [mysqld]\n    2 server-id=2\n    3 relay-log-index=slave-relay-bin.index\n    4 relay-log=slave-relay-bin \n    ```\n    重启 MySQL 服务\n\n    2. 连接 Master\n    ```\n    change master to master_host='192.168.0.104', //Master 服务器Ip\n    master_port=3306,\n    master_user='repl',\n    master_password='mysql', \n    master_log_file='master-bin.000001',//Master服务器产生的日志\n    master_log_pos=0;\n    ```\n\n    3. 启动 Slave\n    ```\n    start slave;\n    ```\n\n3. Slave 从服务器 (Ubuntu)\n    1. 找到 MySQL 安装文件夹修改 my.cnf 文件， vim my.cnf\n    ```\n    [mysqld]\n    basedir =/usr/local/mysql\n    datadir =/usr/local/mysql/data\n    port = 3306\n    server_id = 3\n    relay_log_index=slave-relay-bin.index\n    relay_log=slave-relay-bin\n    ```\n\n    2. ./support-files/myql.server restart 重启MySQL服务  ,  ./bin/mysql 进入MySQL命令窗口 \n\n    3. 连接 Master\n    ```\n    change master to master_host='192.168.0.104', //Master 服务器Ip\n    master_port=3306,\n    master_user='repl',\n    master_password='mysql', \n    master_log_file='master-bin.000001',//Master服务器产生的日志\n    master_log_pos=0;\n    ```\n\n    4. 启动 Slave\n    ```\n    start slave;\n    ```\n\n转自：http://www.cnblogs.com/alvin_xp/p/4162249.html","tags":["架构"]},{"title":"最佳安全实践","url":"/posts/1528164481/","content":"对于需要自行或外包开发信息系统的商户来说，有一些安全的注意事项，我们从 需求、设计、编码、测试、部署&运维 五个方面来展开。  \n1. 需求  \n     a、商户自建营销活动需设计防刷机制。  \n2. 设计  \n     a、数据采集  \n◆ 法律禁止企业记录和存储的数据（如磁道信息、信用卡CVV码等）不能收集。  \n◆ 客户端敏感数据必须先进行加密处理。  \n     b、数据传输  \n◆ 使用HTTPS确保网络传输安全性。  \n◆ 禁用SSL等不安全协议和算法，建议使用TLS1.2。  \n◆ 不要轻易的尝试设计和实现自己的加密传输算法，几乎都会存在问题。  \n     c、数据保存  \n◆ 敏感信息禁止出现在日志中，如确实需要，需进行脱敏处理。  \n◆ 缓存和DB中的敏感数据需进行加密或者虚化（Hash）。  \n◆ 密码等关键认证必须采用加盐Hash方式保存。  \n     d、数据访问  \n◆ 外部请求数据访问必须进行鉴权操作。  \n◆ 对于内部的数据访问要严加控制，降低用户信息泄漏风险。  \n     e、审计日志  \n◆ 记录的操作日志要包括5W信息（Who、When、Why、How、What）。  \n     f、资金处理  \n◆ 建立对账机制，每天对系统收支数据与微信支付数据进行对账，避免资金出现问题。  \n◆ DB或者KV需要设计数据防篡改机制。  \n3. 编码  \n     a、防止参数处理不当导致的常见漏洞  \n◆ 参考 [Web漏洞检测及修复](http://wiki.open.qq.com/wiki/Web漏洞检测及修复)  \n     b、防止逻辑处理不当导致的漏洞  \n◆ 支付成功回调通知必须验证微信支付签名，避免被恶意攻击。  \n◆ 在后台进行商户价格的判断逻辑，避免客户端篡改价格导致商户损失。  \n◆ 避免在App或者网站页面里面出现商户APIkey或API证书等信息，防止泄漏。  \n     c、APP开发安全注意事项  \n◆ IOS应用安全开发参考 [Apple NextPrevious Security Development Checklists](https://developer.apple.com/library/content/documentation/Security/Conceptual/SecureCodingGuide/SecurityDevelopmentChecklists/SecurityDevelopmentChecklists.html)  \n◆ andriod应用安全开发参考 [Andriod Security Tips](https://developer.android.com/training/articles/security-tips.html)\n4. 测试  \n     a、对输入输出参数进行专项安全测试。  \n     b、通过众测或自建、第三方的安全扫描机制对系统进行安全扫描并对问题进行修复。\n5. 部署&运维\n     a、确保系统所使用商业和开源组件的版本是最新稳定版。  \n     b、参考此份checklist进行安全配置 [系统漏洞检测及修复](http://wiki.open.qq.com/wiki/系统漏洞检测及修复)  \n     c、考虑系统和数据服务容灾，至少有主备机制，建议多机房多地部署。  \n     d、建议采用各大云系统，并且启用相关的云安全防控机制。  \n     e、如有条件，建议自建或者购买一些安全监控服务或设备。  \n     f、设定关键指标项，进行实时数据上报和监控  \n     g、有专门的人员来跟进安全事件的处置。  \n     h、关注信息系统所使用框架及组件的安全信息情况。  \n     i、按时打补丁，定期检查系统升级。  \n     j、服务端口开启最小化原则。  \n     k、服务器登录操作可审计。  \n     m、内部管理运营系统必须认证登录做操作日志记录以供审计。  \n     n、建立业务下线机制，不再使用的业务做下线操作减少被攻击面。  \n\n\n转自 https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=23_3#menu1","tags":["安全"]},{"title":"HTTPS服务器配置","url":"/posts/1528164470/","content":"### 一、SSL证书申请\n\n1、确认需要申请证书的域名\n\n2、生成私钥和csr文件  \n在linux机器上执行以下命令生成私钥  \n```\n#openssl genrsa -out server.key 2048  \n```\n在linux机器上执行以下命令生成csr文件  \n```\n#openssl req -new -key server.key -out certreq.csr  \n```\n**以下黑色标识文字仅供参考，请根据商户自己实际情况进行填写**  \nCountry Name： **CN**                      //您所在国家的ISO标准代号，中国为CN  \nState or Province Name：**guandong**       //您单位所在地省/自治区/直辖市  \nLocality Name：**shenzhen**                 //您单位所在地的市/县/区  \nOrganization Name： **Tencent Technology (Shenzhen) Company Limited**                 //您单位/机构/企业合法的名称  \nOrganizational Unit Name： **R&D**         //部门名称  \nCommon Name： **www.example.com**     //通用名，例如：www.itrus.com.cn。此项必须与您访问提供SSL服务的服务器时所应用的域名完全匹配。  \nEmail Address：                          //您的邮件地址，不必输入，直接回车跳过  \n\"extra\"attributes                        //以下信息不必输入，回车跳过直到命令执行完毕。  \n执行上面的命令后，在当前目录下即可生成私钥文件**server.key**和**certreq.csr** csr文件\n\n3、将生成的csr文件提交给第三方证书颁发机构申请对应域名的服务器证书，同时将私钥文件保存好，以免丢失。\n\n4、证书申请后，证书颁发机构会提供服务器证书内容和两张中级CA证书，请按证书颁发机器说明生成服务器证书，此处假设服务器证书文件名称为**server.pem**\n\n5、将生成的私钥文件**server.key**和服务器证书**server.pem**拷贝至服务器指定的目录即可进行HTTPS服务器配置\n\n### 二、HTTPS服务器配置\n\n1、 Nginx配置\n```nginx\nserver {\nlisten       443;   #指定ssl监听端口\nserver_name  www.example.com;\nssl on;    #开启ssl支持\nssl_certificate      /etc/nginx/server.pem;    #指定服务器证书路径\nssl_certificate_key  /etc/nginx/server.key;    #指定私钥证书路径\nssl_session_timeout  5m;\nssl_protocols TLSv1 TLSv1.1 TLSv1.2;     #指定SSL服务器端支持的协议版本\nssl_ciphers  ALL：!ADH：!EXPORT56：RC4+RSA：+HIGH：+MEDIUM：+LOW：+SSLv2：+EXP;    #指定加密算法\nssl_prefer_server_ciphers   on;    #在使用SSLv3和TLS协议时指定服务器的加密算法要优先于客户端的加密算法\n#以下内容请按域名需要进行配置，此处仅供参考\nlocation / {\nreturn 444;\n}\n}\n```\n2、其它web服务器配置\n请参考文档：http://www.itrus.cn/html/fuwuyuzhichi/fuwuqizhengshuanzhuangpeizhizhinan 《服务器证书配置指南》\n\n三、相关事项\n\n1、证书颁发机构  \n推荐天威诚信，具体请见：http://www.itrus.com.cn\n\n2、 参考文档  \nhttp://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_prefer_server_ciphers 《ngx_http_ssl_module》\nhttp://nginx.org/cn/docs/http/configuring_https_servers.html 《nginx配置HTTPS服务器》\nhttp://www.itrus.cn/html/fuwuyuzhichi/fuwuqizhengshuanzhuangpeizhizhinan 《服务器证书配置指南》\n\n3、常见问题  \n（1）证书受信任的问题  \n部分国内签发的SSL证书，在Android上不受信任，推荐GeoTrust；  \n（2）如果页面有动静分离，静态资源使用独立域名的话，也需要为该域名申请证书；  \n（3）android低版本不支持SNI扩展，受此限制，一台服务器只能部署一个数字证书；\n\n---------------------------------------\n\n转自 https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=10_4\n\n参考资料：\n自动生成 web 服务器 https 配置：https://mozilla.github.io/server-side-tls/ssl-config-generator/\n\n免费证书：[Let's Encrypt](https://letsencrypt.org/), [StartSSL](https://www.startssl.com/Support?v=39)\n\n免费CDN：[CloudFlare](https://www.cloudflare.com/ssl/)","tags":["最佳实践"]},{"title":"javascript阻止网页操作完成后自动跳转","url":"/posts/1528164457/","content":"阻止跳转的代码：\n```js\n$(window).on('beforeunload', () => { console.log('leave'); return false; });\n```\n```js\nwindow.addEventListener('beforeunload', function(){console.log('leave');return false;});\n```\n\n参考来源：https://jingyan.baidu.com/article/574c52190bc5ac6c8d9dc196.html","tags":["javascript"]},{"title":"打包网页完整内容的一个方法","url":"/posts/1528164446/","content":"用 safari 保存网站为归档，格式为 webarchive ，用 WebArchive Extractor 解压缩。\n\n这样不但能保存完整的 html, javascript, css，而且\b每个文件分开，非常直观。"},{"title":"redis sentinel主从模式","url":"/posts/1528164430/","content":"# 什么是 sentinel 模式\nsentinel 的中文意思是哨兵，即有一个守护进程，时刻检查主服务的状态，如果挂了，就把从服务改成主服务。而客户端都从 sentinel 给的 ip 读写，不用理会服务有没有挂。\n\n一般我们会设置主-从-从，即第二个从服务从第一个从服务同步数据。这样的结构，即保证了主挂掉后还有一个从分担压力，又不会因为一主二从，增加主服务的同步压力。\n\n# 配置服务\n## 配置 redis\n```sh\n$ redis-server --port 30001 --cluster-node-timeout 2000 --appendonly yes --appendfilename appendonly-30001.aof --dbfilename dump-30001.rdb --logfile 30001.log --daemonize yes\n$ redis-server --port 30002 --cluster-node-timeout 2000 --appendonly yes --appendfilename appendonly-30002.aof --dbfilename dump-30002.rdb --logfile 30002.log --daemonize yes --slaveof 127.0.0.1:30001\n```\n\n## 配置 sentinal\n```sh\n# Sentinel节点的端口\nport 30007\nlogfile \"30007.log\"\n\n# 当前Sentinel节点监控 127.0.0.1:30001 这个主节点\n# 2代表判断主节点失败至少需要2个Sentinel节点节点同意\n# mymaster是主节点的别名\nsentinel monitor mymaster 127.0.0.1 30001 2\n\n# 每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过30000毫秒且没有回复，则判定不可达\nsentinel down-after-milliseconds mymaster 30000\n\n# 当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1\nsentinel parallel-syncs mymaster 1\n\n# 故障转移超时时间为180000毫秒\nsentinel failover-timeout mymaster 180000\n```\n\n## 启动\n有两种方法\n```sh\nredis-sentinel sentinel-30007.conf\nredis-server sentinel-30007.conf\n```\n改一下端口，其他不变启动 30008, 30009 两台，sentinel 彼此会自动发现对方\n\n## 确认\n```sh\n$ redis-cli -p 30007 info sentinel\n# Sentinel\nsentinel_masters:1\nsentinel_tilt:0\nsentinel_running_scripts:0\nsentinel_scripts_queue_length:0\nsentinel_simulate_failure_flags:0\nmaster0:name=mymaster,status=ok,address=127.0.0.1:30001,slaves=1,sentinels=3 # sentinel=3 表示 sentinel 已经彼此发现\n```\n\n现在杀死主\n```sh\n$ ps aux | grep redis\nsimon            56248   0.3  0.0  4309624   2028   ??  Ss    8:50下午   0:00.56 ../../src/redis-sentinel *:30008 [sentinel]\nsimon            56250   0.3  0.0  4309624   2068   ??  Ss    8:50下午   0:00.56 ../../src/redis-sentinel *:30009 [sentinel]\nsimon            56203   0.2  0.0  4309624   2004   ??  Ss    8:46下午   0:01.04 ../../src/redis-sentinel *:30007 [sentinel]\nsimon            55341   0.1  0.0  4310648    988   ??  Ss    4:23下午   0:08.04 ../../src/redis-server *:30001\nsimon            55344   0.1  0.0  4310648   1008   ??  Ss    4:24下午   0:08.10 ../../src/redis-server *:30002\n\n$ kill 55341\n\n$ redis-cli -p 30007 info sentinel\n# Sentinel\nsentinel_masters:1\nsentinel_tilt:0\nsentinel_running_scripts:0\nsentinel_scripts_queue_length:0\nsentinel_simulate_failure_flags:0\nmaster0:name=mymaster,status=ok,address=127.0.0.1:30002,slaves=1,sentinels=3\n```\n此时的 master 地址已经变为 127.0.0.1:30002。\n\n## 查看主从状态\nredis 客户端连上 sentinel 后有\n```sh\ninfo sentinel\nsentinel masters\nsentinel slaves mymaster\n```\n三个常用的命令查看主从状态\n\n# 我踩到的坑\n昨天配置了 redis sentinel 的主从切换，无论如何都无法成功，网上也都不到原因。\n\n后来观察 sentinel 是正常工作的，可是服务器之间只传递 sdown 没有传递 odown，于是用这个搜到了。原来 sentinel 有 protected mode，要在配置里添加 bind 0.0.0.0。改完了之后终于切换成功了。\n\n这个东西弄了我有10小时吧，配置模版里提都没提，真是大坑。\n\n\n-----------------------------\n参考资料：  \n官方文档 https://redis.io/topics/sentinel  \nRedis Sentinel 介绍与部署 https://blog.csdn.net/men_wen/article/details/72724406","tags":["redis"]},{"title":"用人话教你设计模式","url":"/posts/1528164421/","content":"![Design Patterns For Humans](https://cloud.githubusercontent.com/assets/11269635/23065273/1b7e5938-f515-11e6-8dd3-d0d58de6bb9a.png)\n\n***\n<p align=\"center\">\n🎉 对设计模式的极简说明！🎉\n</p>\n<p align=\"center\">\n这个话题可以轻易让任何人糊涂。现在我尝试通过用<i>最简单</i>的方式说明它们，来让你（和我）把他们吃透。\n</p>\n***\n\n🚀 简介\n=================\n\n设计模式用来解决重复的问题；**是解决特定问题的指导方针**。它们不是类(class)，包(packages)，或者库(libraries)，你不能引入它们，然后等待奇迹发生。它们是针对解决特定环境下特定问题的指导方针。\n\n> 设计模式用来解决重复的问题；是解决特定问题的指导方针\n\n维基百科的解释\n\n> In software engineering, a software design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations.\n\n⚠️ 请注意\n-----------------\n- 设计模式不是解决你所有问题的银弹。\n- 不要尝试强行使用它们；如果做了，不好的事情可能发生。请记住设计模式是**解决**问题的方案，不是**发现**问题；所以不要过度思考。\n- 如果在正确的地方以正确的方式使用，它们被证明是有帮助的；否则结果可能是一堆可怕混乱的代码。\n\n> 下面的代码示例使用 PHP-7 书写，但你不应止步于此，因为理念是相通的。再加上,**对其他语言的支持正在路上**。\n\n设计模式的种类\n-----------------\n\n* [创建型](#创建型模式)\n* [结构型](#结构型模式)\n* [行为型](#行为型模式)\n\n创建型模式\n==========================\n\n白话\n> 创建型模式侧重如何实例化一个对象或一组相关对象。\n\n维基百科\n> In software engineering, creational design patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.\n \n * [简单工厂模式 Simple Factory](#-简单工厂模式)\n * [工厂方法模式 Factory Method](#-工厂方法模式)\n * [抽象工厂模式 Abstract Factory](#-抽象工厂模式)\n * [建造者模式 Builder](#-建造者模式)\n * [原型模式 Prototype](#-原型模式)\n * [单例模式 Singleton](#-单例模式)\n \n🏠 简单工厂模式\n--------------\n现实例子\n> 假设，你正在建造一所房子，你需要门。如果每次你需要一扇门你都要穿上木工服开始在房子里造扇门，将会是一团乱。取而代之的是让工厂造好。\n\n白话\n> 简单工厂模式在不暴露生成逻辑的前提下生成一个实例。\n\n维基百科\n> In object-oriented programming (OOP), a factory is an object for creating other objects – formally a factory is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be \"new\".\n\n**代码例子**\n\n首先，我们有一个门的接口和实现\n```php\ninterface Door {\n    public function getWidth() : float;\n    public function getHeight() : float;\n}\n\nclass WoodenDoor implements Door {\n    protected $width;\n    protected $height;\n\n    public function __construct(float $width, float $height) {\n        $this->width = $width;\n        $this->height = $height;\n    }\n    \n    public function getWidth() : float {\n        return $this->width;\n    }\n    \n    public function getHeight() : float {\n        return $this->height;\n    }\n}\n```\n然后，我们有了工厂来制造和返回门\n```php\nclass DoorFactory {\n   public static function makeDoor($width, $height) : Door {\n       return new WoodenDoor($width, $height);\n   }\n}\n```\n然后这样使用\n```php\n$door = DoorFactory::makeDoor(100, 200);\necho 'Width: ' . $door->getWidth();\necho 'Height: ' . $door->getHeight();\n```\n\n**什么时候使用？**\n\n当创建一个对象不只是几个赋值和逻辑计算，把这件工作交给一个工厂而不是到处重复相同的代码就比较合适了。\n\n🏭 工厂方法模式\n--------------\n\n现实例子\n> 设想一个人事经理。一个人是不可能面试所有职位的。基于职位空缺，她必须把面试委托给不同的人。\n\n白话\n> 它提供了一个把生成逻辑移交给子类的方法。\n\n维基百科\n> In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.\n \n **代码例子**\n \n以上面的人事经理为例。首先我们有一个面试官接口和一些实现\n\n```php\ninterface Interviewer {\n    public function askQuestions();\n}\n\nclass Developer implements Interviewer {\n    public function askQuestions() {\n        echo 'Asking about design patterns!';\n    }\n}\n\nclass CommunityExecutive implements Interviewer {\n    public function askQuestions() {\n        echo 'Asking about community building';\n    }\n}\n```\n\n现在我们新建我们的人事经理 `HiringManager`\n\n```php\nabstract class HiringManager {\n    \n    // Factory method\n    abstract public function makeInterviewer() : Interviewer;\n    \n    public function takeInterview() {\n        $interviewer = $this->makeInterviewer();\n        $interviewer->askQuestions();\n    }\n}\n```\n现在任何一个都可以继承它，并且生成需要的面试官\n```php\nclass DevelopmentManager extends HiringManager {\n    public function makeInterviewer() : Interviewer {\n        return new Developer();\n    }\n}\n\nclass MarketingManager extends HiringManager {\n    public function makeInterviewer() : Interviewer {\n        return new CommunityExecutive();\n    }\n}\n```\n然后可以这样使用\n\n```php\n$devManager = new DevelopmentManager();\n$devManager->takeInterview(); // Output: Asking about design patterns\n\n$marketingManager = new MarketingManager();\n$marketingManager->takeInterview(); // Output: Asking about community building.\n```\n\n**何时使用？**\n\n当一个类里有普遍性的处理过程，但是子类要在运行时才确定。或者换句话说，调用者不知道它需要哪个子类。\n\n🔨 抽象工厂模式\n----------------\n\n现实例子\n> 扩展我们简单工厂模式的例子。基于你的需求，你可以从木门店得到一扇木门，从铁门店得到一扇铁门，或者从塑料门店得到一扇塑料门。而且你需要一个有不同专长的人来安装这扇门，比如一个木匠来安木门，焊工来安铁门等。正如你看的，门和安装工有依赖性，木门需要木匠，铁门需要焊工等。\n\n白话\n> 一个制造工厂的工厂；一个工厂把独立但是相关／有依赖性的工厂进行分类，但是不需要给出具体的类。\n  \n维基百科\n> The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes\n\n**代码例子**\n\n翻译上面门的例子。首先我们有了门 `Door` 的接口和一些实现\n\n```php\ninterface Door {\n    public function getDescription();\n}\n\nclass WoodenDoor implements Door {\n    public function getDescription() {\n        echo 'I am a wooden door';\n    }\n}\n\nclass IronDoor implements Door {\n    public function getDescription() {\n        echo 'I am an iron door';\n    }\n}\n```\n然后我们有了每种门的安装专家\n\n```php\ninterface DoorFittingExpert {\n    public function getDescription();\n}\n\nclass Welder implements DoorFittingExpert {\n    public function getDescription() {\n        echo 'I can only fit iron doors';\n    }\n}\n\nclass Carpenter implements DoorFittingExpert {\n    public function getDescription() {\n        echo 'I can only fit wooden doors';\n    }\n}\n```\n\n现在我们有了抽象工厂来创建全部相关的对象，即木门工厂制造木门和木门安装专家，铁门工厂制造铁门和铁门安装专家\n```php\ninterface DoorFactory {\n    public function makeDoor() : Door;\n    public function makeFittingExpert() : DoorFittingExpert;\n}\n\n// 木头工厂返回木门和木匠\nclass WoodenDoorFactory implements DoorFactory {\n    public function makeDoor() : Door {\n        return new WoodenDoor();\n    }\n\n    public function makeFittingExpert() : DoorFittingExpert{\n        return new Carpenter();\n    }\n}\n\n// 铁门工厂返回铁门和对应安装专家\nclass IronDoorFactory implements DoorFactory {\n    public function makeDoor() : Door {\n        return new IronDoor();\n    }\n\n    public function makeFittingExpert() : DoorFittingExpert{\n        return new Welder();\n    }\n}\n```\n然后可以这样使用\n```php\n$woodenFactory = new WoodenDoorFactory();\n\n$door = $woodenFactory->makeDoor();\n$expert = $woodenFactory->makeFittingExpert();\n\n$door->getDescription();  // 输出: I am a wooden door\n$expert->getDescription(); // 输出: I can only fit wooden doors\n\n// 铁门工厂也一样\n$ironFactory = new IronDoorFactory();\n\n$door = $ironFactory->makeDoor();\n$expert = $ironFactory->makeFittingExpert();\n\n$door->getDescription();  // 输出: I am an iron door\n$expert->getDescription(); // 输出: I can only fit iron doors\n```\n\n如你所见，木门工厂包含了木匠 `carpenter` 和木门 `wooden door` 而铁门工厂包含了铁门 `iron door` 和焊工 `welder`。因此我们可以确保每扇制造出来的门不会带上错误的安装工。\n\n**何时使用？**\n\n当创建逻辑不那么简单，而且相互之间有依赖时\n\n👷 建造者模式\n--------------------------------------------\n现实例子\n> 想象你在麦当劳，你要一个“巨无霸”，他们马上就给你了，没有疑问，这是简单工厂的逻辑。但如果创建逻辑包含更多步骤。比如你想要一个自定义赛百味套餐，你有多种选择来制作汉堡，例如你要哪种面包？你要哪种调味酱？你要哪种奶酪？等。这种情况就需要建造者模式来处理。\n\n白话\n> 让你能创建不同特点的对象而避免构造函数污染。当一个对象都多种特点的时候比较实用。或者在创造逻辑里有许多步骤的时候。\n \n维基百科\n> The builder pattern is an object creation software design pattern with the intentions of finding a solution to the telescoping constructor anti-pattern.\n\n话虽如此，让我写一点关于伸缩构造函数反面模式。在某些时候，我们都看过下面这样的构造函数\n \n```php\npublic function __construct($size, $cheese = true, $pepperoni = true, $tomato = false, $lettuce = true) {\n}\n```\n\n如你所见；构造函数参数的数量马上就要失去控制，而且梳理参数也会变得困难。而且如果你将来想要增加更多选项，参数也会继续增加。这就叫做伸缩构造函数反面模式。\n\n**代码例子**\n\n正常的做法是使用创建者模式。首先我们有了要做的汉堡\n\n```php\nclass Burger {\n    protected $size;\n\n    protected $cheese = false;\n    protected $pepperoni = false;\n    protected $lettuce = false;\n    protected $tomato = false;\n    \n    public function __construct(BurgerBuilder $builder) {\n        $this->size = $builder->size;\n        $this->cheese = $builder->cheese;\n        $this->pepperoni = $builder->pepperoni;\n        $this->lettuce = $builder->lettuce;\n        $this->tomato = $builder->tomato;\n    }\n}\n```\n\n然后我们有了制作者\n\n```php\nclass BurgerBuilder {\n    public $size;\n\n    public $cheese = false;\n    public $pepperoni = false;\n    public $lettuce = false;\n    public $tomato = false;\n\n    public function __construct(int $size) {\n        $this->size = $size;\n    }\n    \n    public function addPepperoni() {\n        $this->pepperoni = true;\n        return $this;\n    }\n    \n    public function addLettuce() {\n        $this->lettuce = true;\n        return $this;\n    }\n    \n    public function addCheese() {\n        $this->cheese = true;\n        return $this;\n    }\n    \n    public function addTomato() {\n        $this->tomato = true;\n        return $this;\n    }\n    \n    public function build() : Burger {\n        return new Burger($this);\n    }\n}\n```\n然后可以这样使用\n\n```php\n$burger = (new BurgerBuilder(14))\n                    ->addPepperoni()\n                    ->addLettuce()\n                    ->addTomato()\n                    ->build();\n```\n\n**何时使用？**\n\n当对象有多种特性而要避免构造函数变长。和工厂模式的核心区别是；当创建过程只有一个步骤的时候使用工厂模式，而当创建过程有多个步骤的时候使用创造者模式。\n\n🐑 原型模式\n------------\n现实例子\n> 记得多利吗？那只克隆羊！不要在意细节，现在的重点是克隆\n\n白话\n> 通过克隆已有的对象来创建新对象。\n\n维基百科\n> The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.\n\n长话短说，它让你创建已有对象的拷贝，然后修改到你要的样子，而不是从头开始建造。\n\n**代码例子**\n\n在 PHP 里，简单的使用 `clone` 就可以了\n  \n```php\nclass Sheep {\n    protected $name;\n    protected $category;\n\n    public function __construct(string $name, string $category = 'Mountain Sheep') {\n        $this->name = $name;\n        $this->category = $category;\n    }\n    \n    public function setName(string $name) {\n        $this->name = $name;\n    }\n\n    public function getName() {\n        return $this->name;\n    }\n\n    public function setCategory(string $category) {\n        $this->category = $category;\n    }\n\n    public function getCategory() {\n        return $this->category;\n    }\n}\n```\n然后它可以被这样克隆\n```php\n$original = new Sheep('Jolly');\necho $original->getName(); // Jolly\necho $original->getCategory(); // Mountain Sheep\n\n// Clone and modify what is required\n$cloned = clone $original;\n$cloned->setName('Dolly');\necho $cloned->getName(); // Dolly\necho $cloned->getCategory(); // Mountain sheep\n```\n\n你也可以使用魔法方法 `__clone` 来改变克隆逻辑。\n\n**何时使用？**\n\n当一个对象需要跟已有的对象相似，或者当创造过程比起克隆来太昂贵时。\n\n💍 单例模式\n------------\n现实例子\n> 一个国家同一时间只能有一个总统。当使命召唤的时候，这个总统要采取行动。这里的总统就是单例的。\n\n白话\n> 确保指定的类只生成一个对象。\n\n维基百科\n> In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.\n\n单例模式其实被看作一种反面模式，应该避免过度使用。它不一定不好，而且确有一些有效的用例，但是应该谨慎使用，因为它在你的应用里引入了全局状态，在一个地方改变，会影响其他地方。而且很难 debug 。另一个坏处是它让你的代码紧耦合，而且很难仿制单例。\n\n**代码例子**\n\n要创建一个单例，先让构造函数私有，不能克隆，不能继承，然后创造一个静态变量来保存这个实例\n```php\nfinal class President {\n    private static $instance;\n\n    private function __construct() {\n        // Hide the constructor\n    }\n    \n    public static function getInstance() : President {\n        if (!self::$instance) {\n            self::$instance = new self();\n        }\n        \n        return self::$instance;\n    }\n    \n    private function __clone() {\n        // Disable cloning\n    }\n    \n    private function __wakeup() {\n        // Disable unserialize\n    }\n}\n```\n然后要使用的话\n```php\n$president1 = President::getInstance();\n$president2 = President::getInstance();\n\nvar_dump($president1 === $president2); // true\n```\n\n结构型模式\n==========================\n白话\n> 结构型模式更关注对象的组合，换句话说，实体如何彼此使用。或者说，它们帮助解答“如何建造软件组件？”\n\n维基百科\n> In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships between entities.\n  \n * [适配器模式 Adapter](#-适配器模式)\n * [桥接模式 Bridge](#-桥接模式)\n * [组合模式 Composite](#-组合模式)\n * [装饰器模式 Decorator](#-装饰器模式)\n * [门面模式 Facade](#-门面模式)\n * [享元模式 Flyweight](#-享元模式)\n * [代理模式 Proxy](#-代理模式)\n\n🔌 适配器模式\n-------\n现实例子\n> 假设在你的存储卡里有一些照片，你要把它们传到电脑。为了传输，你需要一个兼容电脑端口的适配器来连接存储卡和电脑。在这里，读卡器就是一个适配器。\n> 另一个例子是电源转换器；一个三脚的插口不能插到两口的插座上，它需要一个电源转换器来兼容两口的插座。\n> 还有一个例子是翻译将一个人说的话翻译给另一个人。\n\n白话\n> 适配器模式让你封装一个不兼容的对象到一个适配器，来兼容其他类。\n\n维基百科\n> In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.\n\n**代码例子**\n\n假设一个猎人狩猎狮子的游戏。\n\n首先我们有了一个接口狮子 `Lion` 来实现所有种类的狮子\n\n```php\ninterface Lion {\n    public function roar();\n}\n\nclass AfricanLion implements Lion {\n    public function roar() {}\n}\n\nclass AsianLion implements Lion {\n    public function roar() {}\n}\n```\n以及猎人需要狩猎任何狮子 `Lion` 接口的实现。\n```php\nclass Hunter {\n    public function hunt(Lion $lion) {\n    }\n}\n```\n\n现在我们不得不在游戏里加一个野狗 `WildDog` ，猎人也能狩猎它。但是我们不能直接这么做，因为狗有不同的接口。为了兼容我们的猎人，我们不得不创建一个兼容的适配器\n \n```php\n// This needs to be added to the game\nclass WildDog {\n    public function bark() {}\n}\n\n// Adapter around wild dog to make it compatible with our game\nclass WildDogAdapter implements Lion {\n    protected $dog;\n\n    public function __construct(WildDog $dog) {\n        $this->dog = $dog;\n    }\n    \n    public function roar() {\n        $this->dog->bark();\n    }\n}\n```\n现在野狗 `WildDog` 可以在游戏里使用了，通过野狗适配器 `WildDogAdapter`.\n\n```php\n$wildDog = new WildDog();\n$wildDogAdapter = new WildDogAdapter($wildDog);\n\n$hunter = new Hunter();\n$hunter->hunt($wildDogAdapter);\n```\n\n🚡 桥接模式\n------\n现实例子\n> 假设你有一个包含很多网页的网站，你想要用户可以改变主题。你会怎么做？创建每个页面对应每个主题的拷备，还是只是创建不同的主题，然后根据用户的喜好来加载它们？桥接模式让你能做到后者。\n\n![With and without the bridge pattern](https://cloud.githubusercontent.com/assets/11269635/23065293/33b7aea0-f515-11e6-983f-98823c9845ee.png)\n\n白话\n> 桥接模式倾向构造而非继承。实现细节被从一个层推送到另一个对象的另一层。\n\n维基百科\n> The bridge pattern is a design pattern used in software engineering that is meant to \"decouple an abstraction from its implementation so that the two can vary independently\"\n\n**代码例子**\n\n翻译我们上面的网页例子。这里是网页 `WebPage` 层\n\n```php\ninterface WebPage {\n    public function __construct(Theme $theme);\n    public function getContent();\n}\n\nclass About implements WebPage {\n    protected $theme;\n    \n    public function __construct(Theme $theme) {\n        $this->theme = $theme;\n    }\n    \n    public function getContent() {\n        return \"About page in \" . $this->theme->getColor();\n    }\n}\n\nclass Careers implements WebPage {\n   protected $theme;\n   \n   public function __construct(Theme $theme) {\n       $this->theme = $theme;\n   }\n   \n   public function getContent() {\n       return \"Careers page in \" . $this->theme->getColor();\n   } \n}\n```\n以及主题层\n```php\ninterface Theme {\n    public function getColor();\n}\n\nclass DarkTheme implements Theme {\n    public function getColor() {\n        return 'Dark Black';\n    }\n}\nclass LightTheme implements Theme {\n    public function getColor() {\n        return 'Off white';\n    }\n}\nclass AquaTheme implements Theme {\n    public function getColor() {\n        return 'Light blue';\n    }\n}\n```\n两个层的互动\n```php\n$darkTheme = new DarkTheme();\n\n$about = new About($darkTheme);\n$careers = new Careers($darkTheme);\n\necho $about->getContent(); // \"About page in Dark Black\";\necho $careers->getContent(); // \"Careers page in Dark Black\";\n```\n\n🌿 组合模式\n-----------------\n\n现实例子\n> 任何组织都是由员工组成。每个员工都有相同的特征，即一笔薪水，一些责任，可能需要向别人汇报，可能有一些下属等。\n\n白话\n> 组合模式让调用者可以用统一的模式对待不同的对象。\n\n维基百科\n> In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes that a group of objects is to be treated in the same way as a single instance of an object. The intent of a composite is to \"compose\" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.\n\n**代码例子**\n\n拿上面的员工为例。下面是不同的员工类型\n\n```php\n\ninterface Employee {\n    public function __construct(string $name, float $salary);\n    public function getName() : string;\n    public function setSalary(float $salary);\n    public function getSalary() : float;\n    public function getRoles()  : array;\n}\n\nclass Developer implements Employee {\n\n    protected $salary;\n    protected $name;\n\n    public function __construct(string $name, float $salary) {\n        $this->name = $name;\n        $this->salary = $salary;\n    }\n\n    public function getName() : string {\n        return $this->name;\n    }\n\n    public function setSalary(float $salary) {\n        $this->salary = $salary;\n    }\n\n    public function getSalary() : float {\n        return $this->salary;\n    }\n\n    public function getRoles() : array {\n        return $this->roles;\n    }\n}\n\nclass Designer implements Employee {\n\n    protected $salary;\n    protected $name;\n\n    public function __construct(string $name, float $salary) {\n        $this->name = $name;\n        $this->salary = $salary;\n    }\n\n    public function getName() : string {\n        return $this->name;\n    }\n\n    public function setSalary(float $salary) {\n        $this->salary = $salary;\n    }\n\n    public function getSalary() : float {\n        return $this->salary;\n    }\n\n    public function getRoles() : array {\n        return $this->roles;\n    }\n}\n```\n\n下面是一个由不同类型员工组成的组织\n\n```php\nclass Organization {\n    \n    protected $employees;\n\n    public function addEmployee(Employee $employee) {\n        $this->employees[] = $employee;\n    }\n\n    public function getNetSalaries() : float {\n        $netSalary = 0;\n\n        foreach ($this->employees as $employee) {\n            $netSalary += $employee->getSalary();\n        }\n\n        return $netSalary;\n    }\n}\n```\n\n然后可以这样使用\n\n```php\n// 准备员工\n$john = new Developer('John Doe', 12000);\n$jane = new Designer('Jane', 10000);\n\n// 把他们加到组织里去\n$organization = new Organization();\n$organization->addEmployee($john);\n$organization->addEmployee($jane);\n\necho \"Net salaries: \" . $organization->getNetSalaries(); // Net Salaries: 22000\n```\n\n☕ 装饰器模式\n-------------\n\n现实例子\n\n> 想象你开一家汽车服务店，提供各种服务。现在你怎么计算收费？你选择一个服务，然后不断把价格加到已选服务的价格里，直到得到总价。这里，每种服务就是一个装饰器。\n\n白话\n> 装饰器模式让你能在运行时动态地改变一个对象的表现，通过把它们封装到一个装饰器类。\n\n维基百科\n> In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern.\n\n**代码例子**\n\n让我们以咖啡为例。首先我们有一个咖啡接口的简单实现\n\n```php\ninterface Coffee {\n    public function getCost();\n    public function getDescription();\n}\n\nclass SimpleCoffee implements Coffee {\n\n    public function getCost() {\n        return 10;\n    }\n\n    public function getDescription() {\n        return 'Simple coffee';\n    }\n}\n```\n我们想要让代码可扩展，以在需要的时候改变选项。让我们增加一些扩展（装饰器）\n```php\nclass MilkCoffee implements Coffee {\n    \n    protected $coffee;\n\n    public function __construct(Coffee $coffee) {\n        $this->coffee = $coffee;\n    }\n\n    public function getCost() {\n        return $this->coffee->getCost() + 2;\n    }\n\n    public function getDescription() {\n        return $this->coffee->getDescription() . ', milk';\n    }\n}\n\nclass WhipCoffee implements Coffee {\n\n    protected $coffee;\n\n    public function __construct(Coffee $coffee) {\n        $this->coffee = $coffee;\n    }\n\n    public function getCost() {\n        return $this->coffee->getCost() + 5;\n    }\n\n    public function getDescription() {\n        return $this->coffee->getDescription() . ', whip';\n    }\n}\n\nclass VanillaCoffee implements Coffee {\n\n    protected $coffee;\n\n    public function __construct(Coffee $coffee) {\n        $this->coffee = $coffee;\n    }\n\n    public function getCost() {\n        return $this->coffee->getCost() + 3;\n    }\n\n    public function getDescription() {\n        return $this->coffee->getDescription() . ', vanilla';\n    }\n}\n\n```\n\n现在让我们生成咖啡\n\n```php\n$someCoffee = new SimpleCoffee();\necho $someCoffee->getCost(); // 10\necho $someCoffee->getDescription(); // Simple Coffee\n\n$someCoffee = new MilkCoffee($someCoffee);\necho $someCoffee->getCost(); // 12\necho $someCoffee->getDescription(); // Simple Coffee, milk\n\n$someCoffee = new WhipCoffee($someCoffee);\necho $someCoffee->getCost(); // 17\necho $someCoffee->getDescription(); // Simple Coffee, milk, whip\n\n$someCoffee = new VanillaCoffee($someCoffee);\necho $someCoffee->getCost(); // 20\necho $someCoffee->getDescription(); // Simple Coffee, milk, whip, vanilla\n```\n\n📦 门面模式\n----------------\n\n现实例子\n> 你怎么打开电脑？你会说“按电源键”！你这么认为是因为你在用电脑外部提供的简单接口，而在内部，它必须做很做工作来实现这件事。这个复杂子系统的简单接口就是一个门面。\n\n白话\n> 门面模式提供了一个复杂子系统的简单接口。\n\n维基百科\n> A facade is an object that provides a simplified interface to a larger body of code, such as a class library.\n\n**代码例子**\n\n拿上面电脑为例。下面是电脑类\n\n```php\nclass Computer {\n\n    public function getElectricShock() {\n        echo \"Ouch!\";\n    }\n\n    public function makeSound() {\n        echo \"Beep beep!\";\n    }\n\n    public function showLoadingScreen() {\n        echo \"Loading..\";\n    }\n\n    public function bam() {\n        echo \"Ready to be used!\";\n    }\n\n    public function closeEverything() {\n        echo \"Bup bup bup buzzzz!\";\n    }\n\n    public function sooth() {\n        echo \"Zzzzz\";\n    }\n\n    public function pullCurrent() {\n        echo \"Haaah!\";\n    }\n}\n```\n下面是门面\n```php\nclass ComputerFacade\n{\n    protected $computer;\n\n    public function __construct(Computer $computer) {\n        $this->computer = $computer;\n    }\n\n    public function turnOn() {\n        $this->computer->getElectricShock();\n        $this->computer->makeSound();\n        $this->computer->showLoadingScreen();\n        $this->computer->bam();\n    }\n\n    public function turnOff() {\n        $this->computer->closeEverything();\n        $this->computer->pullCurrent();\n        $this->computer->sooth();\n    }\n}\n```\n如何使用门面\n```php\n$computer = new ComputerFacade(new Computer());\n$computer->turnOn(); // Ouch! Beep beep! Loading.. Ready to be used!\n$computer->turnOff(); // Bup bup buzzz! Haah! Zzzzz\n```\n\n🍃 享元模式\n---------\n\n现实例子\n> 你在小店里喝过茶吗？他们经常比你要的多做几杯，把剩下的留给别的客人，以此来省资源，比如煤气。享元模式就是以上的体现，即分享。\n\n白话\n> 通过尽可能分享相似的对象，来将内存使用或计算开销降到最低。\n\n维基百科\n> In computer programming, flyweight is a software design pattern. A flyweight is an object that minimizes memory use by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory.\n\n**代码例子**\n\n翻译上面的茶的例子。首先我们有了茶的类型和生成器\n\n```php\n// 任何被缓存的东西都被叫做享元。 \n// 这里茶的类型就是享元。\nclass KarakTea {\n}\n\n// 像工厂一样工作，保存茶\nclass TeaMaker {\n    protected $availableTea = [];\n\n    public function make($preference) {\n        if (empty($this->availableTea[$preference])) {\n            $this->availableTea[$preference] = new KarakTea();\n        }\n\n        return $this->availableTea[$preference];\n    }\n}\n```\n\n下面是我们的茶吧 `TeaShop` ，接单和提供服务\n\n```php\nclass TeaShop {\n    \n    protected $orders;\n    protected $teaMaker;\n\n    public function __construct(TeaMaker $teaMaker) {\n        $this->teaMaker = $teaMaker;\n    }\n\n    public function takeOrder(string $teaType, int $table) {\n        $this->orders[$table] = $this->teaMaker->make($teaType);\n    }\n\n    public function serve() {\n        foreach($this->orders as $table => $tea) {\n            echo \"Serving tea to table# \" . $table;\n        }\n    }\n}\n```\n然后可以这样使用\n\n```php\n$teaMaker = new TeaMaker();\n$shop = new TeaShop($teaMaker);\n\n$shop->takeOrder('less sugar', 1);\n$shop->takeOrder('more milk', 2);\n$shop->takeOrder('without sugar', 5);\n\n$shop->serve();\n// Serving tea to table# 1\n// Serving tea to table# 2\n// Serving tea to table# 5\n```\n\n🎱 代理模式\n-------------------\n现实例子\n> 你有没有用过门卡来通过一扇门？有多种方式来打开那扇门，即它可以被门卡打开，或者按开门按钮打开。这扇门的主要功能是开关，但在顶层增加了一个代理来增加其他功能。下面的例子能更好的说明。\n\n白话\n> 使用代理模式，一个类表现出了另一个类的功能。\n\n维基百科\n> A proxy, in its most general form, is a class functioning as an interface to something else. A proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked.\n\n**代码例子**\n\n拿上面安全门为例。首先我们有了门的接口和实现\n\n```php\ninterface Door {\n    public function open();\n    public function close();\n}\n\nclass LabDoor implements Door {\n    public function open() {\n        echo \"Opening lab door\";\n    }\n\n    public function close() {\n        echo \"Closing the lab door\";\n    }\n}\n```\n然后下面是一个代理来安保任何我们要的门\n```php\nclass Security {\n    protected $door;\n\n    public function __construct(Door $door) {\n        $this->door = $door;\n    }\n\n    public function open($password) {\n        if ($this->authenticate($password)) {\n            $this->door->open();\n        } else {\n        \techo \"Big no! It ain't possible.\";\n        }\n    }\n\n    public function authenticate($password) {\n        return $password === '$ecr@t';\n    }\n\n    public function close() {\n        $this->door->close();\n    }\n}\n```\n然后可以这样使用\n```php\n$door = new Security(new LabDoor());\n$door->open('invalid'); // Big no! It ain't possible.\n\n$door->open('$ecr@t'); // Opening lab door\n$door->close(); // Closing lab door\n```\n另一个例子是一些数据映射的实现。比如，我最近用这个模式给 MongoDB 做了一个数据映射器 ODM (Object Data Mapper)，我用魔术方法 `__call()` 给 mongo 类做了一个代理。所有执行的方法都被代理到原始的 mongo 类，返回收到的结果。但是在 `find` 或 `findOne` 的情况，数据被映射到对应的对象，这个对象会被返回，而不是 `Cursor`。\n\n行为型模式\n==========================\n\n白话\n> 它关注对象间的责任分配。它们和结构型模式的区别是它们不止明确指明结构，而且指出了它们之间传递/交流的信息的形式。或者换句或说，它们帮助回答了“如何确定软件组件的行为？”\n\n维基百科\n> In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication.\n\n* [责任链模式 Chain of Responsibility](#-责任链模式)\n* [命令模式 Command](#-命令模式)\n* [迭代器模式 Iterator](#-迭代器模式)\n* [中介模式 Mediator](#-中介模式)\n* [备忘录模式 Memento](#-备忘录模式)\n* [观察者模式 Observer](#-观察者模式)\n* [访问者模式 Visitor](#-访问者模式)\n* [策略模式 Strategy](#-策略模式)\n* [状态模式 State](#-状态模式)\n* [模板模式 Template Method](#-模板模式)\n\n🔗 责任链模式\n-----------------------\n\n现实例子\n> 比如，有三个支付方式 (`A`, `B` 和 `C`) 安装在你的账户里；每种方式都有不同额度。`A` 有 100 元， `B` 有 300 元，以及 `C` 有 1000 元，选择支付方式的顺序是 `A` 然后 `B` 然后 `C`。你要买一些价值 210 元的东西。使用责任链模式，首先账户 `A` 会被检查是否能够支付，如果是，支付会被执行而链子终止。如果否，请求会转移到账户 `B`，检查额度，如果是，链子终止，否则请求继续转移直到找到合适的执行者。这里 `A`，`B` 和 `C` 是链接里的环节，它们合起来就是责任链。\n\n白话\n> 它构造了一个对象的链。请求进入一端，然后从一个对象到另一个对象直到找到合适的执行者。\n\n维基百科\n> In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain.\n\n**代码例子**\n\n翻译上面的账户例子。首先我们有了一个基本账户，包含把账户连接起来的逻辑。以及一些账户\n\n```php\nabstract class Account {\n    protected $successor;\n    protected $balance;\n\n    public function setNext(Account $account) {\n        $this->successor = $account;\n    }\n    \n    public function pay(float $amountToPay) {\n        if ($this->canPay($amountToPay)) {\n            echo sprintf('Paid %s using %s' . PHP_EOL, $amountToPay, get_called_class());\n        } else if ($this->successor) {\n            echo sprintf('Cannot pay using %s. Proceeding ..' . PHP_EOL, get_called_class());\n            $this->successor->pay($amountToPay);\n        } else {\n            throw Exception('None of the accounts have enough balance');\n        }\n    }\n    \n    public function canPay($amount) : bool {\n        return $this->balance >= $amount;\n    }\n}\n\nclass Bank extends Account {\n    protected $balance;\n\n    public function __construct(float $balance) {\n        $this->balance = $balance;\n    }\n}\n\nclass Paypal extends Account {\n    protected $balance;\n\n    public function __construct(float $balance) {\n        $this->balance = $balance;\n    }\n}\n\nclass Bitcoin extends Account {\n    protected $balance;\n\n    public function __construct(float $balance) {\n        $this->balance = $balance;\n    }\n}\n```\n\n现在我们用上面定义的环节（即银行 Bank，贝宝 Paypal，比特币 Bitcoin）准备链\n\n```php\n// 我们准备下面这样的链\n//      $bank->$paypal->$bitcoin\n//\n// 首选银行 bank\n//      如果银行 bank 不能支付则选择贝宝 paypal\n//      如果贝宝 paypal 不能支付则选择比特币 bit coin\n\n$bank = new Bank(100);          // 银行 Bank 有余额 100\n$paypal = new Paypal(200);      // 贝宝 Paypal 有余额 200\n$bitcoin = new Bitcoin(300);    // 比特币 Bitcoin 有余额 300\n\n$bank->setNext($paypal);\n$paypal->setNext($bitcoin);\n\n// 我们尝试用首选项支付，即银行 bank\n$bank->pay(259);\n\n// 输出将会是\n// ==============\n// Cannot pay using bank. Proceeding ..\n// Cannot pay using paypal. Proceeding ..: \n// Paid 259 using Bitcoin!\n```\n\n👮 命令模式\n-------\n\n现实例子\n> 一个普遍的例子是你在餐馆点餐。你 (即调用者 `Client`) 要求服务员 (即调用器 `Invoker`) 端来一些食物 (即命令 `Command`)，而服务员只是简单的把命令传达给知道怎么做菜的厨师 (即接收者 `Receiver`)。另一个例子是你 (即调用者 `Client`) 打开 (即命令 `Command`) 电视 (即接收者 `Receiver`)，通过使用遥控 (调用器 `Invoker`).\n\n白话\n> 允许你封装对象的功能。此模式的核心思想是分离调用者和接收者。\n\n维基百科\n> In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters.\n\n**代码例子**\n\n首先我们有一个接收者，包含了每一个可执行的功能的实现\n```php\n// Receiver\nclass Bulb {\n    public function turnOn() {\n        echo \"Bulb has been lit\";\n    }\n    \n    public function turnOff() {\n        echo \"Darkness!\";\n    }\n}\n```\n然后下面是每个命令执行的接口，之后我们就有了一个命令的集合\n```php\ninterface Command {\n    public function execute();\n    public function undo();\n    public function redo();\n}\n\n// Command\nclass TurnOn implements Command {\n    protected $bulb;\n    \n    public function __construct(Bulb $bulb) {\n        $this->bulb = $bulb;\n    }\n    \n    public function execute() {\n        $this->bulb->turnOn();\n    }\n    \n    public function undo() {\n        $this->bulb->turnOff();\n    }\n    \n    public function redo() {\n        $this->execute();\n    }\n}\n\nclass TurnOff implements Command {\n    protected $bulb;\n    \n    public function __construct(Bulb $bulb) {\n        $this->bulb = $bulb;\n    }\n    \n    public function execute() {\n        $this->bulb->turnOff();\n    }\n    \n    public function undo() {\n        $this->bulb->turnOn();\n    }\n    \n    public function redo() {\n        $this->execute();\n    }\n}\n```\n然后我们有了一个执行器 `Invoker`，调用者可以通过它执行命令\n```php\n// Invoker\nclass RemoteControl {\n    \n    public function submit(Command $command) {\n        $command->execute();\n    }\n}\n```\n最后我们看看可以如何使用\n```php\n$bulb = new Bulb();\n\n$turnOn = new TurnOn($bulb);\n$turnOff = new TurnOff($bulb);\n\n$remote = new RemoteControl();\n$remote->submit($turnOn); // Bulb has been lit!\n$remote->submit($turnOff); // Darkness!\n```\n\n命令模式也可以用来实现一个基础系统的事务。当你要一直在执行命令后马上维护日志。如果命令被正确执行，一切正常，否则沿日志迭代，一直对每个已执行的命令执行撤销 `undo` 。\n\n➿ 迭代器模式\n--------\n\n现实例子\n> 老式调频收音机是迭代器的好例子，用户可以在一些频道开始，然后使用前进或后退按钮来浏览每个频道。或者以 MP3 播放器或电视机为例，你可以按前进或后退按钮来浏览连续的频道。或者说，它们都提供了迭代连续的频道，歌曲或广播的接口。  \n\n白话\n> 它提供了一种方式来获得对象的元素，而不必暴露底层实现。\n\n维基百科\n> In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.\n\n**代码例子**\n\n在 PHP 里，用 SPL (标准 PHP 库) 实现非常简单。翻译上面的广播例子。首先我们有了广播台 `RadioStation`\n\n```php\nclass RadioStation {\n    protected $frequency;\n\n    public function __construct(float $frequency) {\n        $this->frequency = $frequency;    \n    }\n    \n    public function getFrequency() : float {\n        return $this->frequency;\n    }\n}\n```\n下面是我们的迭代器\n\n```php\nuse Countable;\nuse Iterator;\n\nclass StationList implements Countable, Iterator {\n    /** @var RadioStation[] $stations */\n    protected $stations = [];\n    \n    /** @var int $counter */\n    protected $counter;\n    \n    public function addStation(RadioStation $station) {\n        $this->stations[] = $station;\n    }\n    \n    public function removeStation(RadioStation $toRemove) {\n        $toRemoveFrequency = $toRemove->getFrequency();\n        $this->stations = array_filter($this->stations, function (RadioStation $station) use ($toRemoveFrequency) {\n            return $station->getFrequency() !== $toRemoveFrequency;\n        });\n    }\n    \n    public function count() : int {\n        return count($this->stations);\n    }\n    \n    public function current() : RadioStation {\n        return $this->stations[$this->counter];\n    }\n    \n    public function key() {\n        return $this->counter;\n    }\n    \n    public function next() {\n        $this->counter++;\n    }\n    \n    public function rewind() {\n        $this->counter = 0;\n    }\n    \n    public function valid(): bool\n    {\n        return isset($this->stations[$this->counter]);\n    }\n}\n```\n然后可以这样使用\n```php\n$stationList = new StationList();\n\n$stationList->addStation(new Station(89));\n$stationList->addStation(new Station(101));\n$stationList->addStation(new Station(102));\n$stationList->addStation(new Station(103.2));\n\nforeach($stationList as $station) {\n    echo $station->getFrequency() . PHP_EOL;\n}\n\n$stationList->removeStation(new Station(89)); // Will remove station 89\n```\n\n👽 中介模式\n========\n\n现实例子\n> 一个普遍的例子是当你用手机和别人谈话，你和别人中间隔了一个电信网，你的声音穿过它而不是直接发出去。在这里，电信网就是一个中介。\n\n白话\n> 中介模式增加了一个第三方对象（叫做中介）来控制两个对象（叫做同事）间的交互。它帮助减少类彼此之间交流的耦合度。因为它们现在不需要知道彼此的实现。 \n\n维基百科\n> In software engineering, the mediator pattern defines an object that encapsulates how a set of objects interact. This pattern is considered to be a behavioral pattern due to the way it can alter the program's running behavior.\n\n**代码例子**\n\n下面是一个最简单的聊天室（即中介）的例子，用户（即同事）彼此发送信息。\n\n首先，我们有一个中介，即聊天室\n\n```php\n// 中介\nclass ChatRoom implements ChatRoomMediator {\n    public function showMessage(User $user, string $message) {\n        $time = date('M d, y H:i');\n        $sender = $user->getName();\n\n        echo $time . '[' . $sender . ']:' . $message;\n    }\n}\n```\n\n然后我们有用户，即同事\n```php\nclass User {\n    protected $name;\n    protected $chatMediator;\n\n    public function __construct(string $name, ChatRoomMediator $chatMediator) {\n        $this->name = $name;\n        $this->chatMediator = $chatMediator;\n    }\n    \n    public function getName() {\n        return $this->name;\n    }\n    \n    public function send($message) {\n        $this->chatMediator->showMessage($this, $message);\n    }\n}\n```\n然后是使用\n```php\n$mediator = new ChatRoom();\n\n$john = new User('John Doe', $mediator);\n$jane = new User('Jane Doe', $mediator);\n\n$john->send('Hi there!');\n$jane->send('Hey!');\n\n// 输出将会是\n// Feb 14, 10:58 [John]: Hi there!\n// Feb 14, 10:58 [Jane]: Hey!\n```\n\n💾 备忘录模式\n-------\n现实例子\n> 以计算器（即发起人）为例，无论什么时候你执行一些计算，最后的计算都会保存在内存（即备忘）里，这样你就能返回到这里，并且用一些按钮（即守护者）恢复。 \n\n白话\n> 备忘录模式捕捉和保存当前对象的状态，然后用一种平滑的方式恢复。\n\n维基百科\n> The memento pattern is a software design pattern that provides the ability to restore an object to its previous state (undo via rollback).\n\n当你要提供撤销方法时异常实用。\n\n**代码例子**\n\n让我们那编辑器为例，编辑器一直保存状态，在你需要的时候可以恢复。\n\n首先下面是我们的备忘录对象，可以保存编辑器状态\n\n```php\nclass EditorMemento {\n    protected $content;\n    \n    public function __construct(string $content) {\n        $this->content = $content;\n    }\n    \n    public function getContent() {\n        return $this->content;\n    }\n}\n```\n\n然后是我们的编辑器，即发起者，来使用备忘录对象\n\n```php\nclass Editor {\n    protected $content = '';\n    \n    public function type(string $words) {\n        $this->content = $this->content . ' ' . $words;\n    }\n    \n    public function getContent() {\n        return $this->content;\n    }\n    \n    public function save() {\n        return new EditorMemento($this->content);\n    }\n    \n    public function restore(EditorMemento $memento) {\n        $this->content = $memento->getContent();\n    }\n}\n```\n\n然后可以这样使用\n\n```php\n$editor = new Editor();\n\n// 输入一些东西\n$editor->type('This is the first sentence.');\n$editor->type('This is second.');\n\n// 保存状态到：This is the first sentence. This is second.\n$saved = $editor->save();\n\n// 输入些别的东西\n$editor->type('And this is third.');\n\n// 输出: Content before Saving\necho $editor->getContent(); // This is the first sentence. This is second. And this is third.\n\n// 恢复到上次保存状态\n$editor->restore($saved);\n\n$editor->getContent(); // This is the first sentence. This is second.\n```\n\n😎 观察者模式\n--------\n现实例子\n> 一个好的例子是求职者，他们订阅了一些工作发布网站，当有合适的工作机会时，他们会收到提醒。   \n\n白话\n> 定义了一个对象间的依赖，这样无论何时一个对象改变了状态，其他所有依赖者会收到提醒。\n\n维基百科\n> The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.\n\n**代码例子**\n\n翻译上面的例子。首先我们有需要收到工作发布提醒的求职者\n```php\nclass JobPost {\n    protected $title;\n    \n    public function __construct(string $title) {\n        $this->title = $title;\n    }\n    \n    public function getTitle() {\n        return $this->title;\n    }\n}\n\nclass JobSeeker implements Observer {\n    protected $name;\n\n    public function __construct(string $name) {\n        $this->name = $name;\n    }\n\n    public function onJobPosted(JobPost $job) {\n        // Do something with the job posting\n        echo 'Hi ' . $this->name . '! New job posted: '. $job->getTitle();\n    }\n}\n```\n下面是求职者订阅的工作信息\n```php\nclass JobPostings implements Observable {\n    protected $observers = [];\n    \n    protected function notify(JobPost $jobPosting) {\n        foreach ($this->observers as $observer) {\n            $observer->onJobPosted($jobPosting);\n        }\n    }\n    \n    public function attach(Observer $observer) {\n        $this->observers[] = $observer;\n    }\n    \n    public function addJob(JobPost $jobPosting) {\n        $this->notify($jobPosting);\n    }\n}\n```\n然后可以这样使用\n```php\n// 创建订阅者\n$johnDoe = new JobSeeker('John Doe');\n$janeDoe = new JobSeeker('Jane Doe');\n\n// 创建发布者，绑定订阅者\n$jobPostings = new JobPostings();\n$jobPostings->attach($johnDoe);\n$jobPostings->attach($janeDoe);\n\n// 添加一个工作，看订阅者是否收到通知\n$jobPostings->addJob(new JobPost('Software Engineer'));\n\n// 输出\n// Hi John Doe! New job posted: Software Engineer\n// Hi Jane Doe! New job posted: Software Engineer\n```\n\n🏃 访问者模式\n-------\n现实例子\n> 假设一些人访问迪拜。他们需要一些方式（即签证）来进入迪拜。抵达后，他们可以去迪拜的任何地方，而不用申请许可或者跑腿；他们知道的地方都可以去。访问者模式可以让你这样做，它帮你添加可以访问的地方，然后他们可以访问尽可能多的地方而不用到处跑腿。\n\n白话\n> 访问者模式可以让你添加更多的操作到对象，而不用改变他们。\n    \n维基百科\n> In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying those structures. It is one way to follow the open/closed principle.\n\n**代码例子**\n\n让我们以动物园模拟器为例，在里面我们有一些动物，我们必须让他们叫。让我们用访问者模式来翻译\n\n```php\n// 被访者\ninterface Animal {\n    public function accept(AnimalOperation $operation);\n}\n\n// 访问者\ninterface AnimalOperation {\n    public function visitMonkey(Monkey $monkey);\n    public function visitLion(Lion $lion);\n    public function visitDolphin(Dolphin $dolphin);\n}\n```\nThen we have our implementations for the animals\n```php\nclass Monkey implements Animal {\n    \n    public function shout() {\n        echo 'Ooh oo aa aa!';\n    }\n\n    public function accept(AnimalOperation $operation) {\n        $operation->visitMonkey($this);\n    }\n}\n\nclass Lion implements Animal {\n    public function roar() {\n        echo 'Roaaar!';\n    }\n    \n    public function accept(AnimalOperation $operation) {\n        $operation->visitLion($this);\n    }\n}\n\nclass Dolphin implements Animal {\n    public function speak() {\n        echo 'Tuut tuttu tuutt!';\n    }\n    \n    public function accept(AnimalOperation $operation) {\n        $operation->visitDolphin($this);\n    }\n}\n```\n实现我们的访问者\n```php\nclass Speak implements AnimalOperation {\n    public function visitMonkey(Monkey $monkey) {\n        $monkey->shout();\n    }\n    \n    public function visitLion(Lion $lion) {\n        $lion->roar();\n    }\n    \n    public function visitDolphin(Dolphin $dolphin) {\n        $dolphin->speak();\n    }\n}\n```\n\n然后可以这样使用\n```php\n$monkey = new Monkey();\n$lion = new Lion();\n$dolphin = new Dolphin();\n\n$speak = new Speak();\n\n$monkey->accept($speak);    // Ooh oo aa aa!    \n$lion->accept($speak);      // Roaaar!\n$dolphin->accept($speak);   // Tuut tutt tuutt!\n```\n我们本可以简单地给动物加一个继承层来做到这点，但是这样每当我们要给动物增加新功能的时候，我们就不得不改变动物。但是现在我们不用改变他们。比如，我们要给动物增加一个跳的行为，我们可以通过简单地增加一个新的访问者\n\n```php\nclass Jump implements AnimalOperation {\n    public function visitMonkey(Monkey $monkey) {\n        echo 'Jumped 20 feet high! on to the tree!';\n    }\n    \n    public function visitLion(Lion $lion) {\n        echo 'Jumped 7 feet! Back on the ground!';\n    }\n    \n    public function visitDolphin(Dolphin $dolphin) {\n        echo 'Walked on water a little and disappeared';\n    }\n}\n```\n然后这样用\n```php\n$jump = new Jump();\n\n$monkey->accept($speak);   // Ooh oo aa aa!\n$monkey->accept($jump);    // Jumped 20 feet high! on to the tree!\n\n$lion->accept($speak);     // Roaaar!\n$lion->accept($jump);      // Jumped 7 feet! Back on the ground! \n\n$dolphin->accept($speak);  // Tuut tutt tuutt! \n$dolphin->accept($jump);   // Walked on water a little and disappeared\n```\n\n💡 策略模式\n--------\n\n现实例子\n> 考虑排序的例子，我们实现了冒泡排序，但是数据开始增长，冒泡排序变得很慢。为了应对这个，我们实现了快速排序。但现在尽管快速排序算法对大数据集表现更好，小数据集却很慢。为了应对这一点，我们实现一个策略，冒泡排序处理小数据集，快速排序处理大数据集。\n\n白话\n> 策略模式允许你基于情况选择算法或策略。\n\n维基百科\n> In computer programming, the strategy pattern (also known as the policy pattern) is a behavioural software design pattern that enables an algorithm's behavior to be selected at runtime.\n \n**代码例子**\n\n翻译我们上面的例子。首先我们有了策略接口和不同的策略实现\n\n```php\ninterface SortStrategy {\n    public function sort(array $dataset) : array; \n}\n\nclass BubbleSortStrategy implements SortStrategy {\n    public function sort(array $dataset) : array {\n        echo \"Sorting using bubble sort\";\n         \n        // Do sorting\n        return $dataset;\n    }\n} \n\nclass QuickSortStrategy implements SortStrategy {\n    public function sort(array $dataset) : array {\n        echo \"Sorting using quick sort\";\n        \n        // Do sorting\n        return $dataset;\n    }\n}\n```\n \n然后是实用策略的调用者\n```php\nclass Sorter {\n    protected $sorter;\n    \n    public function __construct(SortStrategy $sorter) {\n        $this->sorter = $sorter;\n    }\n    \n    public function sort(array $dataset) : array {\n        return $this->sorter->sort($dataset);\n    }\n}\n```\n然后可以这样使用\n```php\n$dataset = [1, 5, 4, 3, 2, 8];\n\n$sorter = new Sorter(new BubbleSortStrategy());\n$sorter->sort($dataset); // 输出 : Sorting using bubble sort\n\n$sorter = new Sorter(new QuickSortStrategy());\n$sorter->sort($dataset); // 输出 : Sorting using quick sort\n```\n\n💢 状态模式\n-----\n现实例子\n> 想象你在使用画图程序，你选择笔刷来画。现在笔刷根据选择的颜色改变自己的行为。即如果你选择红色，它就用红色画，如果是蓝色它就用蓝色等等。  \n\n白话\n> 他让你能类的状态改变时，改变其行为。\n\n维基百科\n> The state pattern is a behavioral software design pattern that implements a state machine in an object-oriented way. With the state pattern, a state machine is implemented by implementing each individual state as a derived class of the state pattern interface, and implementing state transitions by invoking methods defined by the pattern's superclass.\n> The state pattern can be interpreted as a strategy pattern which is able to switch the current strategy through invocations of methods defined in the pattern's interface.\n\n**代码例子**\n\n让我们以编辑器作为例子，它能让你改变文本的状态，比如你选择了加粗，它开始以加粗字体书写，如果选择倾斜，就以倾斜字体等等。\n\n首先，我们有状态接口和一些状态实现\n\n```php\ninterface WritingState {\n    public function write(string $words);\n}\n\nclass UpperCase implements WritingState {\n    public function write(string $words) {\n        echo strtoupper($words); \n    }\n} \n\nclass LowerCase implements WritingState {\n    public function write(string $words) {\n        echo strtolower($words); \n    }\n}\n\nclass Default implements WritingState {\n    public function write(string $words) {\n        echo $words;\n    }\n}\n```\n下面是我们的编辑器\n```php\nclass TextEditor {\n    protected $state;\n    \n    public function __construct(WritingState $state) {\n        $this->state = $state;\n    }\n    \n    public function setState(WritingState $state) {\n        $this->state = $state;\n    }\n    \n    public function type(string $words) {\n        $this->state->write($words);\n    }\n}\n```\n然后可以这样使用\n```php\n$editor = new TextEditor(new Default());\n\n$editor->type('First line');\n\n$editor->setState(new UpperCaseState());\n\n$editor->type('Second line');\n$editor->type('Third line');\n\n$editor->setState(new LowerCaseState());\n\n$editor->type('Fourth line');\n$editor->type('Fifth line');\n\n// 输出:\n// First line\n// SECOND LINE\n// THIRD LINE\n// fourth line\n// fifth line\n```\n\n📒 模板模式\n---------------\n\n现实例子\n> 假设我们要建房子。建造的步骤类似这样 \n> - 准备房子的地基\n> - 建造墙\n> - 建造房顶\n> - 然后是地板\n> 这些步骤步骤的顺序永远不会变，即你不能在建墙之前建屋顶，当时每个步骤都可以改变，比如墙可以是木头可以是聚酯或者石头。\n  \n白话\n> 模板模式定义了一个算法会如何执行的骨架，但把这些步骤的实现移交给子类。\n \n维基百科\n> In software engineering, the template method pattern is a behavioral design pattern that defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses. It lets one redefine certain steps of an algorithm without changing the algorithm's structure.\n\n**代码例子**\n\n想象我们有一个构建工具帮我们测试，纠错，构建，生成构建报告（即代码报告，查错报告），然后把应用发布到测试服务器。\n\n首先是我们的基础类，它描述了构建算法的骨架\n```php\nabstract class Builder {\n    \n    // Template method \n    public final function build() {\n        $this->test();\n        $this->lint();\n        $this->assemble();\n        $this->deploy();\n    }\n    \n    public abstract function test();\n    public abstract function lint();\n    public abstract function assemble();\n    public abstract function deploy();\n}\n```\n\n以下是实现\n\n```php\nclass AndroidBuilder extends Builder {\n    public function test() {\n        echo 'Running android tests';\n    }\n    \n    public function lint() {\n        echo 'Linting the android code';\n    }\n    \n    public function assemble() {\n        echo 'Assembling the android build';\n    }\n    \n    public function deploy() {\n        echo 'Deploying android build to server';\n    }\n}\n\nclass IosBuilder extends Builder {\n    public function test() {\n        echo 'Running ios tests';\n    }\n    \n    public function lint() {\n        echo 'Linting the ios code';\n    }\n    \n    public function assemble() {\n        echo 'Assembling the ios build';\n    }\n    \n    public function deploy() {\n        echo 'Deploying ios build to server';\n    }\n}\n```\n然后可以这样使用\n\n```php\n$androidBuilder = new AndroidBuilder();\n$androidBuilder->build();\n\n// 输出:\n// Running android tests\n// Linting the android code\n// Assembling the android build\n// Deploying android build to server\n\n$iosBuilder = new IosBuilder();\n$iosBuilder->build();\n\n// 输出:\n// Running ios tests\n// Linting the ios code\n// Assembling the ios build\n// Deploying ios build to server\n```\n\n## 🚦 收尾了同志们\n\n终于收尾了。我会继续改进这篇文档，所以你或许需要 watch/star 这个仓库，先码后看。\n\n## 👬 Contribution\n\n- Report issues\n- Open pull request with improvements\n- Spread the word\n\n## 翻译\n[月球人](https://github.com/questionlin)\n\n## License\nMIT © [Kamran Ahmed](http://kamranahmed.info)\n","tags":["php"]},{"title":"hexo+github搭建博客最佳实践","url":"/posts/1528164408/","content":"\b在考察了多种方案后最终使用 hexo 搭起了博客，这篇文章写写我是怎么\b使用 hexo 和 github 来搭博客的。\n\n在官网主题那里选一个喜欢的主题，我找了一个有搜索引擎配置教学的。下载后放到 themes 文件夹。然后按照官方说明配置。\n\nhexo 不提供 markdown 编辑器，我使用 vscode，快捷键 command + k 再按 v 后可以打开一个实时预览标签页。\n\n我有一个特殊的需求，希望可以省略部署( hexo deploy) 这个步骤。这就要求博客源文件和生成文件放在一起。github pages 提供给用户专门建\b博客的项目只能放生成后的文件，这个方案否定。我的做法是：\n1. 把 _config.yml 里面的 public_dir 改为 docs\n2. 然后建一个普通的项目仓库，在 settings 里的 github pages Source 选为 master branch/docs folder。这里顺便把 Custom domain 改为自己的域名。\n3. 在域名 dns 设置里面添加 cname 指向 question.github.io\n4. 在文章顶部增加 id，值为 unix 时间戳，以优化 url\n\n用到的插件：\n- hexo-generator-search 用来支持\b搜索\n\n到此我的 hexo 博客就建好了，\b[项目仓库在这里](https://github.com/questionlin/blog)。比官方的方法少了一步。","tags":["hexo"]},{"title":"Hello World","url":"/posts/1528164216/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["hexo"]}]